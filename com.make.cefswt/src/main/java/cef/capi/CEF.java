package cef.capi;
import java.lang.annotation.Annotation;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

// Generated by ffi_gen. Please do not change this file by hand.
import jnr.ffi.LibraryLoader;
import jnr.ffi.LibraryOption;
import jnr.ffi.NativeLong;
import jnr.ffi.Pointer;
import jnr.ffi.Struct;
import jnr.ffi.Union;
import jnr.ffi.annotations.Delegate;
import jnr.ffi.annotations.In;
import jnr.ffi.mapper.FunctionMapper;
import jnr.ffi.util.EnumMapper;

public class CEF {
    public static CEFInterface INSTANCE = CEFInterface.InstanceCreator.createInstance();
    public static jnr.ffi.Runtime RUNTIME;
    
    /*interface NativeEnum {
        public int toNativeInt();
    }*/
    /*
    static Pointer bytesToPointer(byte[] b) {
        Pointer p = Memory.allocate(RUNTIME, b.length);
        p.write(0, b, 0, b.length);
        return p;
    }
    */
    
    public static int STRING_TYPE_UTF16 = 1;
    
    public static int K_NULL_CURSOR_HANDLE = 0;
    
    public static int K_NULL_WINDOW_HANDLE = 0;
    
    /**
     * (Not documented)
     */
    public static final class XEvent extends Union {
        // hidden structure
        public XEvent() {
          super(RUNTIME);
        }
        public XEvent(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     */
    public static final class XDisplay extends Struct {
        // hidden structure
        public XDisplay() {
          super(RUNTIME);
        }
        public XDisplay(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :str ::
     *   (FFI::Pointer(*Wchar)) 
     * :length ::
     *   (Integer) 
     * :dtor ::
     *   (FFI::Pointer(*)) 
     */
    public static final class StringWide extends Struct {
        public Pointer str;
        public NativeLong length;
        public Pointer dtor;
        public StringWide() {
          super(RUNTIME);
        }
        public StringWide(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :str ::
     *   (String) 
     * :length ::
     *   (Integer) 
     * :dtor ::
     *   (FFI::Pointer(*)) 
     */
    public static final class StringUtf8 extends Struct {
        public String str;
        public NativeLong length;
        public Pointer dtor;
        public StringUtf8() {
          super(RUNTIME);
        }
        public StringUtf8(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :str ::
     *   (FFI::Pointer(*Char16)) 
     * :length ::
     *   (Integer) 
     * :dtor ::
     *   (FFI::Pointer(*)) 
     */
    public static final class StringUtf16 extends Struct {
        public Pointer str;
        public NativeLong length;
        public Pointer dtor;
        public StringUtf16() {
          super(RUNTIME);
        }
        public StringUtf16(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * @method stringWideSet(src, srcLen, output, copy)
     * @param [FFI::Pointer(*Wchar)] src 
     * @param [Integer] srcLen 
     * @param [StringWide] output 
     * @param [Integer] copy 
     * @return [Integer] 
     * @scope class
     */
    public static int stringWideSet(Pointer src, NativeLong srcLen, StringWide output, int copy) {
        return INSTANCE.stringWideSet(src, srcLen, output, copy);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf8Set(src, srcLen, output, copy)
     * @param [String] src 
     * @param [Integer] srcLen 
     * @param [StringUtf8] output 
     * @param [Integer] copy 
     * @return [Integer] 
     * @scope class
     */
    public static int stringUtf8Set(String src, NativeLong srcLen, StringUtf8 output, int copy) {
        return INSTANCE.stringUtf8Set(src, srcLen, output, copy);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf16Set(src, srcLen, output, copy)
     * @param [FFI::Pointer(*Char16)] src 
     * @param [Integer] srcLen 
     * @param [StringUtf16] output 
     * @param [Integer] copy 
     * @return [Integer] 
     * @scope class
     */
    public static int stringUtf16Set(Pointer src, NativeLong srcLen, StringUtf16 output, int copy) {
        return INSTANCE.stringUtf16Set(src, srcLen, output, copy);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringWideClear(str)
     * @param [StringWide] str 
     * @return [nil] 
     * @scope class
     */
    public static void stringWideClear(StringWide str) {
        INSTANCE.stringWideClear(str);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf8Clear(str)
     * @param [StringUtf8] str 
     * @return [nil] 
     * @scope class
     */
    public static void stringUtf8Clear(StringUtf8 str) {
        INSTANCE.stringUtf8Clear(str);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf16Clear(str)
     * @param [StringUtf16] str 
     * @return [nil] 
     * @scope class
     */
    public static void stringUtf16Clear(StringUtf16 str) {
        INSTANCE.stringUtf16Clear(str);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringWideCmp(str1, str2)
     * @param [StringWide] str1 
     * @param [StringWide] str2 
     * @return [Integer] 
     * @scope class
     */
    public static int stringWideCmp(StringWide str1, StringWide str2) {
        return INSTANCE.stringWideCmp(str1, str2);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf8Cmp(str1, str2)
     * @param [StringUtf8] str1 
     * @param [StringUtf8] str2 
     * @return [Integer] 
     * @scope class
     */
    public static int stringUtf8Cmp(StringUtf8 str1, StringUtf8 str2) {
        return INSTANCE.stringUtf8Cmp(str1, str2);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf16Cmp(str1, str2)
     * @param [StringUtf16] str1 
     * @param [StringUtf16] str2 
     * @return [Integer] 
     * @scope class
     */
    public static int stringUtf16Cmp(StringUtf16 str1, StringUtf16 str2) {
        return INSTANCE.stringUtf16Cmp(str1, str2);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringWideToUtf8(src, srcLen, output)
     * @param [FFI::Pointer(*Wchar)] src 
     * @param [Integer] srcLen 
     * @param [StringUtf8] output 
     * @return [Integer] 
     * @scope class
     */
    public static int stringWideToUtf8(Pointer src, NativeLong srcLen, StringUtf8 output) {
        return INSTANCE.stringWideToUtf8(src, srcLen, output);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf8ToWide(src, srcLen, output)
     * @param [String] src 
     * @param [Integer] srcLen 
     * @param [StringWide] output 
     * @return [Integer] 
     * @scope class
     */
    public static int stringUtf8ToWide(String src, NativeLong srcLen, StringWide output) {
        return INSTANCE.stringUtf8ToWide(src, srcLen, output);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringWideToUtf16(src, srcLen, output)
     * @param [FFI::Pointer(*Wchar)] src 
     * @param [Integer] srcLen 
     * @param [StringUtf16] output 
     * @return [Integer] 
     * @scope class
     */
    public static int stringWideToUtf16(Pointer src, NativeLong srcLen, StringUtf16 output) {
        return INSTANCE.stringWideToUtf16(src, srcLen, output);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf16ToWide(src, srcLen, output)
     * @param [FFI::Pointer(*Char16)] src 
     * @param [Integer] srcLen 
     * @param [StringWide] output 
     * @return [Integer] 
     * @scope class
     */
    public static int stringUtf16ToWide(Pointer src, NativeLong srcLen, StringWide output) {
        return INSTANCE.stringUtf16ToWide(src, srcLen, output);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf8ToUtf16(src, srcLen, output)
     * @param [String] src 
     * @param [Integer] srcLen 
     * @param [StringUtf16] output 
     * @return [Integer] 
     * @scope class
     */
    public static int stringUtf8ToUtf16(String src, NativeLong srcLen, StringUtf16 output) {
        return INSTANCE.stringUtf8ToUtf16(src, srcLen, output);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf16ToUtf8(src, srcLen, output)
     * @param [FFI::Pointer(*Char16)] src 
     * @param [Integer] srcLen 
     * @param [StringUtf8] output 
     * @return [Integer] 
     * @scope class
     */
    public static int stringUtf16ToUtf8(Pointer src, NativeLong srcLen, StringUtf8 output) {
        return INSTANCE.stringUtf16ToUtf8(src, srcLen, output);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringAsciiToWide(src, srcLen, output)
     * @param [String] src 
     * @param [Integer] srcLen 
     * @param [StringWide] output 
     * @return [Integer] 
     * @scope class
     */
    public static int stringAsciiToWide(String src, NativeLong srcLen, StringWide output) {
        return INSTANCE.stringAsciiToWide(src, srcLen, output);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringAsciiToUtf16(src, srcLen, output)
     * @param [String] src 
     * @param [Integer] srcLen 
     * @param [StringUtf16] output 
     * @return [Integer] 
     * @scope class
     */
    public static int stringAsciiToUtf16(String src, NativeLong srcLen, StringUtf16 output) {
        return INSTANCE.stringAsciiToUtf16(src, srcLen, output);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUserfreeWideAlloc()
     * @return [StringWide] 
     * @scope class
     */
    public static StringWide stringUserfreeWideAlloc() {
        return INSTANCE.stringUserfreeWideAlloc();
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUserfreeUtf8Alloc()
     * @return [StringUtf8] 
     * @scope class
     */
    public static StringUtf8 stringUserfreeUtf8Alloc() {
        return INSTANCE.stringUserfreeUtf8Alloc();
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUserfreeUtf16Alloc()
     * @return [StringUtf16] 
     * @scope class
     */
    public static StringUtf16 stringUserfreeUtf16Alloc() {
        return INSTANCE.stringUserfreeUtf16Alloc();
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUserfreeWideFree(str)
     * @param [StringWide] str 
     * @return [nil] 
     * @scope class
     */
    public static void stringUserfreeWideFree(StringWide str) {
        INSTANCE.stringUserfreeWideFree(str);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUserfreeUtf8Free(str)
     * @param [StringUtf8] str 
     * @return [nil] 
     * @scope class
     */
    public static void stringUserfreeUtf8Free(StringUtf8 str) {
        INSTANCE.stringUserfreeUtf8Free(str);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUserfreeUtf16Free(str)
     * @param [StringUtf16] str 
     * @return [nil] 
     * @scope class
     */
    public static void stringUserfreeUtf16Free(StringUtf16 str) {
        INSTANCE.stringUserfreeUtf16Free(str);
    }
    
    /**
     * (Not documented)
     * 
     * @method getXdisplay()
     * @return [XDisplay] 
     * @scope class
     */
    public static XDisplay getXdisplay() {
        return INSTANCE.getXdisplay();
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :argc ::
     *   (Integer) 
     * :argv ::
     *   (FFI::Pointer(**CharS)) 
     */
    public static final class MainArgs extends Struct {
        public int32_t argc = new int32_t();
//        public String[] argv /*= array(new UTF8StringRef[1])*/;
        public Pointer argv = new Pointer();
        public MainArgs() {
          super(RUNTIME);
        }
        public MainArgs(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
//		public void setArgs(java.lang.String[] args) {
//			argv = array(args);
//		}
		
		protected String[] array(java.lang.String[] array) {
			String[] newArray = new String[array.length];
	        arrayBegin();
            for (int i = 0; i < array.length; ++i) {
//            	newArray[i] = new String(array[i].length(), );
                newArray[i] = new AsciiString(array[i].length());
//                newArray[i].set(array[i]);
            }
	        arrayEnd();
	        return newArray;
	    }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :x ::
     *   (Integer) 
     * :y ::
     *   (Integer) 
     * :width ::
     *   (Integer) 
     * :height ::
     *   (Integer) 
     * :parentWindow ::
     *   (Integer) 
     * :windowlessRenderingEnabled ::
     *   (Integer) Set to true (1) to create the browser using windowless (off-screen)
     *   rendering. No window will be created for the browser and all rendering will
     *   occur via the CefRenderHandler interface. The |parent_window| value will be
     *   used to identify monitor info and to act as the parent window for dialogs,
     *   context menus, etc. If |parent_window| is not provided then the main screen
     *   monitor will be used and some functionality that requires a parent window
     *   may not function correctly. In order to create windowless browsers the
     *   CefSettings.windowless_rendering_enabled value must be set to true.
     * :transparentPaintingEnabled ::
     *   (Integer) Set to true (1) to enable transparent painting in combination with
     *   windowless rendering. When this value is true a transparent background
     *   color will be used (RGBA=0x00000000). When this value is false the
     *   background will be white and opaque.
     * :window ::
     *   (Integer) 
     */
    public static final class WindowInfo extends Struct {
        public int x;
        public int y;
        public int width;
        public int height;
        public NativeLong parent_window;
        public int windowless_rendering_enabled;
        public int transparent_painting_enabled;
        public NativeLong window;
        public WindowInfo() {
          super(RUNTIME);
        }
        public WindowInfo(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:LogSeverity).</em>
     * 
     * === Options:
     * LOGSEVERITY_DEFAULT ::
     *   Default logging (currently INFO logging).
     * LOGSEVERITY_VERBOSE ::
     *   Verbose logging.
     * LOGSEVERITY_INFO ::
     *   INFO logging.
     * LOGSEVERITY_WARNING ::
     *   WARNING logging.
     * LOGSEVERITY_ERROR ::
     *   ERROR logging.
     * LOGSEVERITY_DISABLE ::
     *   Completely disable logging.
     * 
     * @method _enum_LogSeverity_
     * @return [Symbol]
     * @scope class
     */
    public enum LogSeverity implements EnumMapper.IntegerEnum {
        LOGSEVERITY_DEFAULT(0),
        LOGSEVERITY_VERBOSE(1),
        LOGSEVERITY_INFO(2),
        LOGSEVERITY_WARNING(3),
        LOGSEVERITY_ERROR(4),
        LOGSEVERITY_DISABLE(99)
        ;
        
        private int nativeInt;
        
        private LogSeverity(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:State).</em>
     * 
     * === Options:
     * DEFAULT ::
     *   Use the default state for the setting.
     * ENABLED ::
     *   Enable or allow the setting.
     * DISABLED ::
     *   Disable or disallow the setting.
     * 
     * @method _enum_State_
     * @return [Symbol]
     * @scope class
     */
    public enum State implements EnumMapper.IntegerEnum {
        DEFAULT(0),
        ENABLED(1),
        DISABLED(2)
        ;
        
        private int nativeInt;
        
        private State(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :size ::
     *   (Integer) Size of this structure.
     * :singleProcess ::
     *   (Integer) Set to true (1) to use a single process for the browser and renderer. This
     *   run mode is not officially supported by Chromium and is less stable than
     *   the multi-process default. Also configurable using the "single-process"
     *   command-line switch.
     * :noSandbox ::
     *   (Integer) Set to true (1) to disable the sandbox for sub-processes. See
     *   cef_sandbox_win.h for requirements to enable the sandbox on Windows. Also
     *   configurable using the "no-sandbox" command-line switch.
     * :browserSubprocessPath ::
     *   (StringUtf16) The path to a separate executable that will be launched for sub-processes.
     *   By default the browser process executable is used. See the comments on
     *   CefExecuteProcess() for details. Also configurable using the
     *   "browser-subprocess-path" command-line switch.
     * :multiThreadedMessageLoop ::
     *   (Integer) Set to true (1) to have the browser process message loop run in a separate
     *   thread. If false (0) than the CefDoMessageLoopWork() function must be
     *   called from your application message loop. This option is only supported on
     *   Windows.
     * :windowlessRenderingEnabled ::
     *   (Integer) Set to true (1) to enable windowless (off-screen) rendering support. Do not
     *   enable this value if the application does not use windowless rendering as
     *   it may reduce rendering performance on some systems.
     * :commandLineArgsDisabled ::
     *   (Integer) Set to true (1) to disable configuration of browser process features using
     *   standard CEF and Chromium command-line arguments. Configuration can still
     *   be specified using CEF data structures or via the
     *   CefApp::OnBeforeCommandLineProcessing() method.
     * :cachePath ::
     *   (StringUtf16) The location where cache data will be stored on disk. If empty then
     *   browsers will be created in "incognito mode" where in-memory caches are
     *   used for storage and no data is persisted to disk. HTML5 databases such as
     *   localStorage will only persist across sessions if a cache path is
     *   specified. Can be overridden for individual CefRequestContext instances via
     *   the CefRequestContextSettings.cache_path value.
     * :userDataPath ::
     *   (StringUtf16) The location where user data such as spell checking dictionary files will
     *   be stored on disk. If empty then the default platform-specific user data
     *   directory will be used ("~/.cef_user_data" directory on Linux,
     *   "~/Library/Application Support/CEF/User Data" directory on Mac OS X,
     *   "Local Settings\Application Data\CEF\User Data" directory under the user
     *   profile directory on Windows).
     * :persistSessionCookies ::
     *   (Integer) To persist session cookies (cookies without an expiry date or validity
     *   interval) by default when using the global cookie manager set this value to
     *   true (1). Session cookies are generally intended to be transient and most
     *   Web browsers do not persist them. A |cache_path| value must also be
     *   specified to enable this feature. Also configurable using the
     *   "persist-session-cookies" command-line switch. Can be overridden for
     *   individual CefRequestContext instances via the
     *   CefRequestContextSettings.persist_session_cookies value.
     * :persistUserPreferences ::
     *   (Integer) To persist user preferences as a JSON file in the cache path directory set
     *   this value to true (1). A |cache_path| value must also be specified
     *   to enable this feature. Also configurable using the
     *   "persist-user-preferences" command-line switch. Can be overridden for
     *   individual CefRequestContext instances via the
     *   CefRequestContextSettings.persist_user_preferences value.
     * :userAgent ::
     *   (StringUtf16) Value that will be returned as the User-Agent HTTP header. If empty the
     *   default User-Agent string will be used. Also configurable using the
     *   "user-agent" command-line switch.
     * :productVersion ::
     *   (StringUtf16) Value that will be inserted as the product portion of the default
     *   User-Agent string. If empty the Chromium product version will be used. If
     *   |userAgent| is specified this value will be ignored. Also configurable
     *   using the "product-version" command-line switch.
     * :locale ::
     *   (StringUtf16) The locale string that will be passed to WebKit. If empty the default
     *   locale of "en-US" will be used. This value is ignored on Linux where locale
     *   is determined using environment variable parsing with the precedence order:
     *   LANGUAGE, LC_ALL, LC_MESSAGES and LANG. Also configurable using the "lang"
     *   command-line switch.
     * :logFile ::
     *   (StringUtf16) The directory and file name to use for the debug log. If empty a default
     *   log file name and location will be used. On Windows and Linux a "debug.log"
     *   file will be written in the main executable directory. On Mac OS X a
     *   "~/Library/Logs/<app name>_debug.log" file will be written where <app name>
     *   is the name of the main app executable. Also configurable using the
     *   "log-file" command-line switch.
     * :logSeverity ::
     *   (Symbol from _enum_LogSeverity_) The log severity. Only messages of this severity level or higher will be
     *   logged. Also configurable using the "log-severity" command-line switch with
     *   a value of "verbose", "info", "warning", "error", "error-report" or
     *   "disable".
     * :javascriptFlags ::
     *   (StringUtf16) Custom flags that will be used when initializing the V8 JavaScript engine.
     *   The consequences of using custom flags may not be well tested. Also
     *   configurable using the "js-flags" command-line switch.
     * :resourcesDirPath ::
     *   (StringUtf16) The fully qualified path for the resources directory. If this value is
     *   empty the cef.pak and/or devtools_resources.pak files must be located in
     *   the module directory on Windows/Linux or the app bundle Resources directory
     *   on Mac OS X. Also configurable using the "resources-dir-path" command-line
     *   switch.
     * :localesDirPath ::
     *   (StringUtf16) The fully qualified path for the locales directory. If this value is empty
     *   the locales directory must be located in the module directory. This value
     *   is ignored on Mac OS X where pack files are always loaded from the app
     *   bundle Resources directory. Also configurable using the "locales-dir-path"
     *   command-line switch.
     * :packLoadingDisabled ::
     *   (Integer) Set to true (1) to disable loading of pack files for resources and locales.
     *   A resource bundle handler must be provided for the browser and render
     *   processes via CefApp::GetResourceBundleHandler() if loading of pack files
     *   is disabled. Also configurable using the "disable-pack-loading" command-
     *   line switch.
     * :remoteDebuggingPort ::
     *   (Integer) Set to a value between 1024 and 65535 to enable remote debugging on the
     *   specified port. For example, if 8080 is specified the remote debugging URL
     *   will be http://localhost:8080. CEF can be remotely debugged from any CEF or
     *   Chrome browser window. Also configurable using the "remote-debugging-port"
     *   command-line switch.
     * :uncaughtExceptionStackSize ::
     *   (Integer) The number of stack trace frames to capture for uncaught exceptions.
     *   Specify a positive value to enable the CefRenderProcessHandler::
     *   OnUncaughtException() callback. Specify 0 (default value) and
     *   OnUncaughtException() will not be called. Also configurable using the
     *   "uncaught-exception-stack-size" command-line switch.
     * :contextSafetyImplementation ::
     *   (Integer) By default CEF V8 references will be invalidated (the IsValid() method will
     *   return false) after the owning context has been released. This reduces the
     *   need for external record keeping and avoids crashes due to the use of V8
     *   references after the associated context has been released.
     *   
     *   CEF currently offers two context safety implementations with different
     *   performance characteristics. The default implementation (value of 0) uses a
     *   map of hash values and should provide better performance in situations with
     *   a small number contexts. The alternate implementation (value of 1) uses a
     *   hidden value attached to each context and should provide better performance
     *   in situations with a large number of contexts.
     *   
     *   If you need better performance in the creation of V8 references and you
     *   plan to manually track context lifespan you can disable context safety by
     *   specifying a value of -1.
     *   
     *   Also configurable using the "context-safety-implementation" command-line
     *   switch.
     * :ignoreCertificateErrors ::
     *   (Integer) Set to true (1) to ignore errors related to invalid SSL certificates.
     *   Enabling this setting can lead to potential security vulnerabilities like
     *   "man in the middle" attacks. Applications that load content from the
     *   internet should not enable this setting. Also configurable using the
     *   "ignore-certificate-errors" command-line switch. Can be overridden for
     *   individual CefRequestContext instances via the
     *   CefRequestContextSettings.ignore_certificate_errors value.
     * :backgroundColor ::
     *   (Integer) Opaque background color used for accelerated content. By default the
     *   background color will be white. Only the RGB compontents of the specified
     *   value will be used. The alpha component must greater than 0 to enable use
     *   of the background color but will be otherwise ignored.
     * :acceptLanguageList ::
     *   (StringUtf16) Comma delimited ordered list of language codes without any whitespace that
     *   will be used in the "Accept-Language" HTTP header. May be overridden on a
     *   per-browser basis using the CefBrowserSettings.accept_language_list value.
     *   If both values are empty then "en-US,en" will be used. Can be overridden
     *   for individual CefRequestContext instances via the
     *   CefRequestContextSettings.accept_language_list value.
     */
    public static final class Settings extends Struct {
        public NativeLong size;
        public int single_process;
        public int no_sandbox;
        public StringUtf16 browser_subprocess_path;
        public int multi_threaded_message_loop;
        public int windowless_rendering_enabled;
        public int command_line_args_disabled;
        public StringUtf16 cache_path;
        public StringUtf16 user_data_path;
        public int persist_session_cookies;
        public int persist_user_preferences;
        public StringUtf16 user_agent;
        public StringUtf16 product_version;
        public StringUtf16 locale;
        public StringUtf16 log_file;
        public LogSeverity log_severity;
        public StringUtf16 javascript_flags;
        public StringUtf16 resources_dir_path;
        public StringUtf16 locales_dir_path;
        public int pack_loading_disabled;
        public int remote_debugging_port;
        public int uncaught_exception_stack_size;
        public int context_safety_implementation;
        public int ignore_certificate_errors;
        public int background_color;
        public StringUtf16 accept_language_list;
        public Settings() {
          super(RUNTIME);
        }
        public Settings(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :size ::
     *   (Integer) Size of this structure.
     * :cachePath ::
     *   (StringUtf16) The location where cache data will be stored on disk. If empty then
     *   browsers will be created in "incognito mode" where in-memory caches are
     *   used for storage and no data is persisted to disk. HTML5 databases such as
     *   localStorage will only persist across sessions if a cache path is
     *   specified. To share the global browser cache and related configuration set
     *   this value to match the CefSettings.cache_path value.
     * :persistSessionCookies ::
     *   (Integer) To persist session cookies (cookies without an expiry date or validity
     *   interval) by default when using the global cookie manager set this value to
     *   true (1). Session cookies are generally intended to be transient and most
     *   Web browsers do not persist them. Can be set globally using the
     *   CefSettings.persist_session_cookies value. This value will be ignored if
     *   |cache_path| is empty or if it matches the CefSettings.cache_path value.
     * :persistUserPreferences ::
     *   (Integer) To persist user preferences as a JSON file in the cache path directory set
     *   this value to true (1). Can be set globally using the
     *   CefSettings.persist_user_preferences value. This value will be ignored if
     *   |cache_path| is empty or if it matches the CefSettings.cache_path value.
     * :ignoreCertificateErrors ::
     *   (Integer) Set to true (1) to ignore errors related to invalid SSL certificates.
     *   Enabling this setting can lead to potential security vulnerabilities like
     *   "man in the middle" attacks. Applications that load content from the
     *   internet should not enable this setting. Can be set globally using the
     *   CefSettings.ignore_certificate_errors value. This value will be ignored if
     *   |cache_path| matches the CefSettings.cache_path value.
     * :acceptLanguageList ::
     *   (StringUtf16) Comma delimited ordered list of language codes without any whitespace that
     *   will be used in the "Accept-Language" HTTP header. Can be set globally
     *   using the CefSettings.accept_language_list value or overridden on a per-
     *   browser basis using the CefBrowserSettings.accept_language_list value. If
     *   all values are empty then "en-US,en" will be used. This value will be
     *   ignored if |cache_path| matches the CefSettings.cache_path value.
     */
    public static final class RequestContextSettings extends Struct {
        public NativeLong size;
        public StringUtf16 cache_path;
        public int persist_session_cookies;
        public int persist_user_preferences;
        public int ignore_certificate_errors;
        public StringUtf16 accept_language_list;
        public RequestContextSettings() {
          super(RUNTIME);
        }
        public RequestContextSettings(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :size ::
     *   (Integer) Size of this structure.
     * :windowlessFrameRate ::
     *   (Integer) The maximum rate in frames per second (fps) that CefRenderHandler::OnPaint
     *   will be called for a windowless browser. The actual fps may be lower if
     *   the browser cannot generate frames at the requested rate. The minimum
     *   value is 1 and the maximum value is 60 (default 30). This value can also be
     *   changed dynamically via CefBrowserHost::SetWindowlessFrameRate.
     * :standardFontFamily ::
     *   (StringUtf16) Font settings.
     * :fixedFontFamily ::
     *   (StringUtf16) 
     * :serifFontFamily ::
     *   (StringUtf16) 
     * :sansSerifFontFamily ::
     *   (StringUtf16) 
     * :cursiveFontFamily ::
     *   (StringUtf16) 
     * :fantasyFontFamily ::
     *   (StringUtf16) 
     * :defaultFontSize ::
     *   (Integer) 
     * :defaultFixedFontSize ::
     *   (Integer) 
     * :minimumFontSize ::
     *   (Integer) 
     * :minimumLogicalFontSize ::
     *   (Integer) 
     * :defaultEncoding ::
     *   (StringUtf16) Default encoding for Web content. If empty "ISO-8859-1" will be used. Also
     *   configurable using the "default-encoding" command-line switch.
     * :remoteFonts ::
     *   (Symbol from _enum_State_) Controls the loading of fonts from remote sources. Also configurable using
     *   the "disable-remote-fonts" command-line switch.
     * :javascript ::
     *   (Symbol from _enum_State_) Controls whether JavaScript can be executed. Also configurable using the
     *   "disable-javascript" command-line switch.
     * :javascriptOpenWindows ::
     *   (Symbol from _enum_State_) Controls whether JavaScript can be used for opening windows. Also
     *   configurable using the "disable-javascript-open-windows" command-line
     *   switch.
     * :javascriptCloseWindows ::
     *   (Symbol from _enum_State_) Controls whether JavaScript can be used to close windows that were not
     *   opened via JavaScript. JavaScript can still be used to close windows that
     *   were opened via JavaScript or that have no back/forward history. Also
     *   configurable using the "disable-javascript-close-windows" command-line
     *   switch.
     * :javascriptAccessClipboard ::
     *   (Symbol from _enum_State_) Controls whether JavaScript can access the clipboard. Also configurable
     *   using the "disable-javascript-access-clipboard" command-line switch.
     * :javascriptDomPaste ::
     *   (Symbol from _enum_State_) Controls whether DOM pasting is supported in the editor via
     *   execCommand("paste"). The |javascript_access_clipboard| setting must also
     *   be enabled. Also configurable using the "disable-javascript-dom-paste"
     *   command-line switch.
     * :caretBrowsing ::
     *   (Symbol from _enum_State_) Controls whether the caret position will be drawn. Also configurable using
     *   the "enable-caret-browsing" command-line switch.
     * :plugins ::
     *   (Symbol from _enum_State_) Controls whether any plugins will be loaded. Also configurable using the
     *   "disable-plugins" command-line switch.
     * :universalAccessFromFileUrls ::
     *   (Symbol from _enum_State_) Controls whether file URLs will have access to all URLs. Also configurable
     *   using the "allow-universal-access-from-files" command-line switch.
     * :fileAccessFromFileUrls ::
     *   (Symbol from _enum_State_) Controls whether file URLs will have access to other file URLs. Also
     *   configurable using the "allow-access-from-files" command-line switch.
     * :webSecurity ::
     *   (Symbol from _enum_State_) Controls whether web security restrictions (same-origin policy) will be
     *   enforced. Disabling this setting is not recommend as it will allow risky
     *   security behavior such as cross-site scripting (XSS). Also configurable
     *   using the "disable-web-security" command-line switch.
     * :imageLoading ::
     *   (Symbol from _enum_State_) Controls whether image URLs will be loaded from the network. A cached image
     *   will still be rendered if requested. Also configurable using the
     *   "disable-image-loading" command-line switch.
     * :imageShrinkStandaloneToFit ::
     *   (Symbol from _enum_State_) Controls whether standalone images will be shrunk to fit the page. Also
     *   configurable using the "image-shrink-standalone-to-fit" command-line
     *   switch.
     * :textAreaResize ::
     *   (Symbol from _enum_State_) Controls whether text areas can be resized. Also configurable using the
     *   "disable-text-area-resize" command-line switch.
     * :tabToLinks ::
     *   (Symbol from _enum_State_) Controls whether the tab key can advance focus to links. Also configurable
     *   using the "disable-tab-to-links" command-line switch.
     * :localStorage ::
     *   (Symbol from _enum_State_) Controls whether local storage can be used. Also configurable using the
     *   "disable-local-storage" command-line switch.
     * :databases ::
     *   (Symbol from _enum_State_) Controls whether databases can be used. Also configurable using the
     *   "disable-databases" command-line switch.
     * :applicationCache ::
     *   (Symbol from _enum_State_) Controls whether the application cache can be used. Also configurable using
     *   the "disable-application-cache" command-line switch.
     * :webgl ::
     *   (Symbol from _enum_State_) Controls whether WebGL can be used. Note that WebGL requires hardware
     *   support and may not work on all systems even when enabled. Also
     *   configurable using the "disable-webgl" command-line switch.
     * :backgroundColor ::
     *   (Integer) Opaque background color used for the browser before a document is loaded
     *   and when no document color is specified. By default the background color
     *   will be the same as CefSettings.background_color. Only the RGB compontents
     *   of the specified value will be used. The alpha component must greater than
     *   0 to enable use of the background color but will be otherwise ignored.
     * :acceptLanguageList ::
     *   (StringUtf16) Comma delimited ordered list of language codes without any whitespace that
     *   will be used in the "Accept-Language" HTTP header. May be set globally
     *   using the CefBrowserSettings.accept_language_list value. If both values are
     *   empty then "en-US,en" will be used.
     */
    public static final class BrowserSettings extends Struct {
        public NativeLong size;
        public int windowless_frame_rate;
        public StringUtf16 standard_font_family;
        public StringUtf16 fixed_font_family;
        public StringUtf16 serif_font_family;
        public StringUtf16 sans_serif_font_family;
        public StringUtf16 cursive_font_family;
        public StringUtf16 fantasy_font_family;
        public int default_font_size;
        public int default_fixed_font_size;
        public int minimum_font_size;
        public int minimum_logical_font_size;
        public StringUtf16 default_encoding;
        public State remote_fonts;
        public State javascript;
        public State javascript_open_windows;
        public State javascript_close_windows;
        public State javascript_access_clipboard;
        public State javascript_dom_paste;
        public State caret_browsing;
        public State plugins;
        public State universal_access_from_file_urls;
        public State file_access_from_file_urls;
        public State web_security;
        public State image_loading;
        public State image_shrink_standalone_to_fit;
        public State text_area_resize;
        public State tab_to_links;
        public State local_storage;
        public State databases;
        public State application_cache;
        public State webgl;
        public int background_color;
        public StringUtf16 accept_language_list;
        public BrowserSettings() {
          super(RUNTIME);
        }
        public BrowserSettings(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ReturnValue).</em>
     * 
     * === Options:
     * RV_CANCEL ::
     *   Cancel immediately.
     * RV_CONTINUE ::
     *   Continue immediately.
     * RV_CONTINUE_ASYNC ::
     *   Continue asynchronously (usually via a callback).
     * 
     * @method _enum_ReturnValue_
     * @return [Symbol]
     * @scope class
     */
    public enum ReturnValue implements EnumMapper.IntegerEnum {
        RV_CANCEL(0),
        RV_CONTINUE(1),
        RV_CONTINUE_ASYNC(2)
        ;
        
        private int nativeInt;
        
        private ReturnValue(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :spec ::
     *   (StringUtf16) The complete URL specification.
     * :scheme ::
     *   (StringUtf16) Scheme component not including the colon (e.g., "http").
     * :username ::
     *   (StringUtf16) User name component.
     * :password ::
     *   (StringUtf16) Password component.
     * :host ::
     *   (StringUtf16) Host component. This may be a hostname, an IPv4 address or an IPv6 literal
     *   surrounded by square brackets (e.g., "(2001:db8::1)").
     * :port ::
     *   (StringUtf16) Port number component.
     * :origin ::
     *   (StringUtf16) Origin contains just the scheme, host, and port from a URL. Equivalent to
     *   clearing any username and password, replacing the path with a slash, and
     *   clearing everything after that. This value will be empty for non-standard
     *   URLs.
     * :path ::
     *   (StringUtf16) Path component including the first slash following the host.
     * :query ::
     *   (StringUtf16) Query string component (i.e., everything following the '?').
     */
    public static final class Urlparts extends Struct {
        public StringUtf16 spec;
        public StringUtf16 scheme;
        public StringUtf16 username;
        public StringUtf16 password;
        public StringUtf16 host;
        public StringUtf16 port;
        public StringUtf16 origin;
        public StringUtf16 path;
        public StringUtf16 query;
        public Urlparts() {
          super(RUNTIME);
        }
        public Urlparts(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :name ::
     *   (StringUtf16) The cookie name.
     * :value ::
     *   (StringUtf16) The cookie value.
     * :domain ::
     *   (StringUtf16) If |domain| is empty a host cookie will be created instead of a domain
     *   cookie. Domain cookies are stored with a leading "." and are visible to
     *   sub-domains whereas host cookies are not.
     * :path ::
     *   (StringUtf16) If |path| is non-empty only URLs at or below the path will get the cookie
     *   value.
     * :secure ::
     *   (Integer) If |secure| is true the cookie will only be sent for HTTPS requests.
     * :httponly ::
     *   (Integer) If |httponly| is true the cookie will only be sent for HTTP requests.
     * :creation ::
     *   (unknown) The cookie creation date. This is automatically populated by the system on
     *   cookie creation.
     * :lastAccess ::
     *   (unknown) The cookie last access date. This is automatically populated by the system
     *   on access.
     * :hasExpires ::
     *   (Integer) The cookie expiration date is only valid if |has_expires| is true.
     * :expires ::
     *   (unknown) 
     */
    public static final class Cookie extends Struct {
        public StringUtf16 name;
        public StringUtf16 value;
        public StringUtf16 domain;
        public StringUtf16 path;
        public int secure;
        public int httponly;
        public byte creation;
        public byte last_access;
        public int has_expires;
        public byte expires;
        public Cookie() {
          super(RUNTIME);
        }
        public Cookie(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:TerminationStatus).</em>
     * 
     * === Options:
     * TS_ABNORMAL_TERMINATION ::
     *   Non-zero exit status.
     * TS_PROCESS_WAS_KILLED ::
     *   SIGKILL or task manager kill.
     * TS_PROCESS_CRASHED ::
     *   Segmentation fault.
     * 
     * @method _enum_TerminationStatus_
     * @return [Symbol]
     * @scope class
     */
    public enum TerminationStatus implements EnumMapper.IntegerEnum {
        TS_ABNORMAL_TERMINATION(0),
        TS_PROCESS_WAS_KILLED(1),
        TS_PROCESS_CRASHED(2)
        ;
        
        private int nativeInt;
        
        private TerminationStatus(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:PathKey).</em>
     * 
     * === Options:
     * PK_DIR_CURRENT ::
     *   Current directory.
     * PK_DIR_EXE ::
     *   Directory containing PK_FILE_EXE.
     * PK_DIR_MODULE ::
     *   Directory containing PK_FILE_MODULE.
     * PK_DIR_TEMP ::
     *   Temporary directory.
     * PK_FILE_EXE ::
     *   Path and filename of the current executable.
     * PK_FILE_MODULE ::
     *   Path and filename of the module containing the CEF code (usually the libcef
     *   module).
     * PK_LOCAL_APP_DATA ::
     *   "Local Settings\Application Data" directory under the user profile
     *   directory on Windows.
     * PK_USER_DATA ::
     *   "Application Data" directory under the user profile directory on Windows
     *   and "~/Library/Application Support" directory on Mac OS X.
     * 
     * @method _enum_PathKey_
     * @return [Symbol]
     * @scope class
     */
    public enum PathKey implements EnumMapper.IntegerEnum {
        PK_DIR_CURRENT(0),
        PK_DIR_EXE(1),
        PK_DIR_MODULE(2),
        PK_DIR_TEMP(3),
        PK_FILE_EXE(4),
        PK_FILE_MODULE(5),
        PK_LOCAL_APP_DATA(6),
        PK_USER_DATA(7)
        ;
        
        private int nativeInt;
        
        private PathKey(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:StorageType).</em>
     * 
     * === Options:
     * ST_LOCALSTORAGE ::
     *   
     * ST_SESSIONSTORAGE ::
     *   
     * 
     * @method _enum_StorageType_
     * @return [Symbol]
     * @scope class
     */
    public enum StorageType implements EnumMapper.IntegerEnum {
        ST_LOCALSTORAGE(0),
        ST_SESSIONSTORAGE(1)
        ;
        
        private int nativeInt;
        
        private StorageType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:Errorcode).</em>
     * 
     * === Options:
     * ERR_NONE ::
     *   
     * ERR_FAILED ::
     *   
     * ERR_ABORTED ::
     *   
     * ERR_INVALID_ARGUMENT ::
     *   
     * ERR_INVALID_HANDLE ::
     *   
     * ERR_FILE_NOT_FOUND ::
     *   
     * ERR_TIMED_OUT ::
     *   
     * ERR_FILE_TOO_BIG ::
     *   
     * ERR_UNEXPECTED ::
     *   
     * ERR_ACCESS_DENIED ::
     *   
     * ERR_NOT_IMPLEMENTED ::
     *   
     * ERR_CONNECTION_CLOSED ::
     *   
     * ERR_CONNECTION_RESET ::
     *   
     * ERR_CONNECTION_REFUSED ::
     *   
     * ERR_CONNECTION_ABORTED ::
     *   
     * ERR_CONNECTION_FAILED ::
     *   
     * ERR_NAME_NOT_RESOLVED ::
     *   
     * ERR_INTERNET_DISCONNECTED ::
     *   
     * ERR_SSL_PROTOCOL_ERROR ::
     *   
     * ERR_ADDRESS_INVALID ::
     *   
     * ERR_ADDRESS_UNREACHABLE ::
     *   
     * ERR_SSL_CLIENT_AUTH_CERT_NEEDED ::
     *   
     * ERR_TUNNEL_CONNECTION_FAILED ::
     *   
     * ERR_NO_SSL_VERSIONS_ENABLED ::
     *   
     * ERR_SSL_VERSION_OR_CIPHER_MISMATCH ::
     *   
     * ERR_SSL_RENEGOTIATION_REQUESTED ::
     *   
     * ERR_CERT_COMMON_NAME_INVALID ::
     *   
     * ERR_CERT_DATE_INVALID ::
     *   
     * ERR_CERT_AUTHORITY_INVALID ::
     *   
     * ERR_CERT_CONTAINS_ERRORS ::
     *   
     * ERR_CERT_NO_REVOCATION_MECHANISM ::
     *   
     * ERR_CERT_UNABLE_TO_CHECK_REVOCATION ::
     *   
     * ERR_CERT_REVOKED ::
     *   
     * ERR_CERT_INVALID ::
     *   
     * ERR_CERT_WEAK_SIGNATURE_ALGORITHM ::
     *   
     * ERR_CERT_NON_UNIQUE_NAME ::
     *   -209 is available: was ERR_CERT_NOT_IN_DNS.
     * ERR_CERT_WEAK_KEY ::
     *   
     * ERR_CERT_NAME_CONSTRAINT_VIOLATION ::
     *   
     * ERR_CERT_VALIDITY_TOO_LONG ::
     *   
     * ERR_INVALID_URL ::
     *   
     * ERR_DISALLOWED_URL_SCHEME ::
     *   
     * ERR_UNKNOWN_URL_SCHEME ::
     *   
     * ERR_TOO_MANY_REDIRECTS ::
     *   
     * ERR_UNSAFE_REDIRECT ::
     *   
     * ERR_UNSAFE_PORT ::
     *   
     * ERR_INVALID_RESPONSE ::
     *   
     * ERR_INVALID_CHUNKED_ENCODING ::
     *   
     * ERR_METHOD_NOT_SUPPORTED ::
     *   
     * ERR_UNEXPECTED_PROXY_AUTH ::
     *   
     * ERR_EMPTY_RESPONSE ::
     *   
     * ERR_RESPONSE_HEADERS_TOO_BIG ::
     *   
     * ERR_CACHE_MISS ::
     *   
     * ERR_INSECURE_RESPONSE ::
     *   
     * 
     * @method _enum_Errorcode_
     * @return [Symbol]
     * @scope class
     */
    public enum Errorcode implements EnumMapper.IntegerEnum {
        ERR_NONE(0),
        ERR_FAILED(-2),
        ERR_ABORTED(-3),
        ERR_INVALID_ARGUMENT(-4),
        ERR_INVALID_HANDLE(-5),
        ERR_FILE_NOT_FOUND(-6),
        ERR_TIMED_OUT(-7),
        ERR_FILE_TOO_BIG(-8),
        ERR_UNEXPECTED(-9),
        ERR_ACCESS_DENIED(-10),
        ERR_NOT_IMPLEMENTED(-11),
        ERR_CONNECTION_CLOSED(-100),
        ERR_CONNECTION_RESET(-101),
        ERR_CONNECTION_REFUSED(-102),
        ERR_CONNECTION_ABORTED(-103),
        ERR_CONNECTION_FAILED(-104),
        ERR_NAME_NOT_RESOLVED(-105),
        ERR_INTERNET_DISCONNECTED(-106),
        ERR_SSL_PROTOCOL_ERROR(-107),
        ERR_ADDRESS_INVALID(-108),
        ERR_ADDRESS_UNREACHABLE(-109),
        ERR_SSL_CLIENT_AUTH_CERT_NEEDED(-110),
        ERR_TUNNEL_CONNECTION_FAILED(-111),
        ERR_NO_SSL_VERSIONS_ENABLED(-112),
        ERR_SSL_VERSION_OR_CIPHER_MISMATCH(-113),
        ERR_SSL_RENEGOTIATION_REQUESTED(-114),
        ERR_CERT_COMMON_NAME_INVALID(-200),
        ERR_CERT_DATE_INVALID(-201),
        ERR_CERT_AUTHORITY_INVALID(-202),
        ERR_CERT_CONTAINS_ERRORS(-203),
        ERR_CERT_NO_REVOCATION_MECHANISM(-204),
        ERR_CERT_UNABLE_TO_CHECK_REVOCATION(-205),
        ERR_CERT_REVOKED(-206),
        ERR_CERT_INVALID(-207),
        ERR_CERT_WEAK_SIGNATURE_ALGORITHM(-208),
        ERR_CERT_NON_UNIQUE_NAME(-210),
        ERR_CERT_WEAK_KEY(-211),
        ERR_CERT_NAME_CONSTRAINT_VIOLATION(-212),
        ERR_CERT_VALIDITY_TOO_LONG(-213),
        ERR_INVALID_URL(-300),
        ERR_DISALLOWED_URL_SCHEME(-301),
        ERR_UNKNOWN_URL_SCHEME(-302),
        ERR_TOO_MANY_REDIRECTS(-310),
        ERR_UNSAFE_REDIRECT(-311),
        ERR_UNSAFE_PORT(-312),
        ERR_INVALID_RESPONSE(-320),
        ERR_INVALID_CHUNKED_ENCODING(-321),
        ERR_METHOD_NOT_SUPPORTED(-322),
        ERR_UNEXPECTED_PROXY_AUTH(-323),
        ERR_EMPTY_RESPONSE(-324),
        ERR_RESPONSE_HEADERS_TOO_BIG(-325),
        ERR_CACHE_MISS(-400),
        ERR_INSECURE_RESPONSE(-501)
        ;
        
        private int nativeInt;
        
        private Errorcode(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:CertStatus).</em>
     * 
     * === Options:
     * NONE ::
     *   
     * COMMON_NAME_INVALID ::
     *   
     * DATE_INVALID ::
     *   
     * AUTHORITY_INVALID ::
     *   
     * NO_REVOCATION_MECHANISM ::
     *   1 << 3 is reserved for ERR_CERT_CONTAINS_ERRORS (not useful with WinHTTP).
     * UNABLE_TO_CHECK_REVOCATION ::
     *   
     * REVOKED ::
     *   
     * INVALID ::
     *   
     * WEAK_SIGNATURE_ALGORITHM ::
     *   
     * NON_UNIQUE_NAME ::
     *   1 << 9 was used for CERT_STATUS_NOT_IN_DNS
     * WEAK_KEY ::
     *   
     * PINNED_KEY_MISSING ::
     *   1 << 12 was used for CERT_STATUS_WEAK_DH_KEY
     * NAME_CONSTRAINT_VIOLATION ::
     *   
     * VALIDITY_TOO_LONG ::
     *   
     * IS_EV ::
     *   Bits 16 to 31 are for non-error statuses.
     * REV_CHECKING_ENABLED ::
     *   
     * SHA1_SIGNATURE_PRESENT ::
     *   Bit 18 was CERT_STATUS_IS_DNSSEC
     * CT_COMPLIANCE_FAILED ::
     *   
     * 
     * @method _enum_CertStatus_
     * @return [Symbol]
     * @scope class
     */
    public enum CertStatus implements EnumMapper.IntegerEnum {
        NONE(0),
        COMMON_NAME_INVALID(1),
        DATE_INVALID(2),
        AUTHORITY_INVALID(4),
        NO_REVOCATION_MECHANISM(16),
        UNABLE_TO_CHECK_REVOCATION(32),
        REVOKED(64),
        INVALID(128),
        WEAK_SIGNATURE_ALGORITHM(256),
        NON_UNIQUE_NAME(1024),
        WEAK_KEY(2048),
        PINNED_KEY_MISSING(8192),
        NAME_CONSTRAINT_VIOLATION(16384),
        VALIDITY_TOO_LONG(32768),
        IS_EV(65536),
        REV_CHECKING_ENABLED(131072),
        SHA1_SIGNATURE_PRESENT(524288),
        CT_COMPLIANCE_FAILED(1048576)
        ;
        
        private int nativeInt;
        
        private CertStatus(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:WindowOpenDisposition).</em>
     * 
     * === Options:
     * WOD_UNKNOWN ::
     *   
     * WOD_SUPPRESS_OPEN ::
     *   
     * WOD_CURRENT_TAB ::
     *   
     * WOD_SINGLETON_TAB ::
     *   
     * WOD_NEW_FOREGROUND_TAB ::
     *   
     * WOD_NEW_BACKGROUND_TAB ::
     *   
     * WOD_NEW_POPUP ::
     *   
     * WOD_NEW_WINDOW ::
     *   
     * WOD_SAVE_TO_DISK ::
     *   
     * WOD_OFF_THE_RECORD ::
     *   
     * WOD_IGNORE_ACTION ::
     *   
     * 
     * @method _enum_WindowOpenDisposition_
     * @return [Symbol]
     * @scope class
     */
    public enum WindowOpenDisposition implements EnumMapper.IntegerEnum {
        WOD_UNKNOWN(0),
        WOD_SUPPRESS_OPEN(1),
        WOD_CURRENT_TAB(2),
        WOD_SINGLETON_TAB(3),
        WOD_NEW_FOREGROUND_TAB(4),
        WOD_NEW_BACKGROUND_TAB(5),
        WOD_NEW_POPUP(6),
        WOD_NEW_WINDOW(7),
        WOD_SAVE_TO_DISK(8),
        WOD_OFF_THE_RECORD(9),
        WOD_IGNORE_ACTION(10)
        ;
        
        private int nativeInt;
        
        private WindowOpenDisposition(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:DragOperationsMask).</em>
     * 
     * === Options:
     * OPERATION_NONE ::
     *   
     * OPERATION_COPY ::
     *   
     * OPERATION_LINK ::
     *   
     * OPERATION_GENERIC ::
     *   
     * OPERATION_PRIVATE ::
     *   
     * OPERATION_MOVE ::
     *   
     * OPERATION_DELETE ::
     *   
     * 
     * @method _enum_DragOperationsMask_
     * @return [Symbol]
     * @scope class
     */
    public enum DragOperationsMask implements EnumMapper.IntegerEnum {
        OPERATION_NONE(0),
        OPERATION_COPY(1),
        OPERATION_LINK(2),
        OPERATION_GENERIC(4),
        OPERATION_PRIVATE(8),
        OPERATION_MOVE(16),
        OPERATION_DELETE(32)
        ;
        
        private int nativeInt;
        
        private DragOperationsMask(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:V8Accesscontrol).</em>
     * 
     * === Options:
     * ACCESS_CONTROL_DEFAULT ::
     *   
     * ACCESS_CONTROL_ALL_CAN_READ ::
     *   
     * ACCESS_CONTROL_ALL_CAN_WRITE ::
     *   
     * ACCESS_CONTROL_PROHIBITS_OVERWRITING ::
     *   
     * 
     * @method _enum_V8Accesscontrol_
     * @return [Symbol]
     * @scope class
     */
    public enum V8Accesscontrol implements EnumMapper.IntegerEnum {
        ACCESS_CONTROL_DEFAULT(0),
        ACCESS_CONTROL_ALL_CAN_READ(1),
        ACCESS_CONTROL_ALL_CAN_WRITE(2),
        ACCESS_CONTROL_PROHIBITS_OVERWRITING(4)
        ;
        
        private int nativeInt;
        
        private V8Accesscontrol(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:V8Propertyattribute).</em>
     * 
     * === Options:
     * PROPERTY_ATTRIBUTE_NONE ::
     *   
     * PROPERTY_ATTRIBUTE_READONLY ::
     *   Configurable
     * PROPERTY_ATTRIBUTE_DONTENUM ::
     *   Not writeable
     * PROPERTY_ATTRIBUTE_DONTDELETE ::
     *   Not enumerable
     * 
     * @method _enum_V8Propertyattribute_
     * @return [Symbol]
     * @scope class
     */
    public enum V8Propertyattribute implements EnumMapper.IntegerEnum {
        PROPERTY_ATTRIBUTE_NONE(0),
        PROPERTY_ATTRIBUTE_READONLY(1),
        PROPERTY_ATTRIBUTE_DONTENUM(2),
        PROPERTY_ATTRIBUTE_DONTDELETE(4)
        ;
        
        private int nativeInt;
        
        private V8Propertyattribute(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:PostdataelementType).</em>
     * 
     * === Options:
     * PDE_TYPE_EMPTY ::
     *   
     * PDE_TYPE_BYTES ::
     *   
     * PDE_TYPE_FILE ::
     *   
     * 
     * @method _enum_PostdataelementType_
     * @return [Symbol]
     * @scope class
     */
    public enum PostdataelementType implements EnumMapper.IntegerEnum {
        PDE_TYPE_EMPTY(0),
        PDE_TYPE_BYTES(1),
        PDE_TYPE_FILE(2)
        ;
        
        private int nativeInt;
        
        private PostdataelementType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ResourceType).</em>
     * 
     * === Options:
     * RT_MAIN_FRAME ::
     *   Top level page.
     * RT_SUB_FRAME ::
     *   Frame or iframe.
     * RT_STYLESHEET ::
     *   CSS stylesheet.
     * RT_SCRIPT ::
     *   External script.
     * RT_IMAGE ::
     *   Image (jpg/gif/png/etc).
     * RT_FONT_RESOURCE ::
     *   Font.
     * RT_SUB_RESOURCE ::
     *   Some other subresource. This is the default type if the actual type is
     *   unknown.
     * RT_OBJECT ::
     *   Object (or embed) tag for a plugin, or a resource that a plugin requested.
     * RT_MEDIA ::
     *   Media resource.
     * RT_WORKER ::
     *   Main resource of a dedicated worker.
     * RT_SHARED_WORKER ::
     *   Main resource of a shared worker.
     * RT_PREFETCH ::
     *   Explicitly requested prefetch.
     * RT_FAVICON ::
     *   Favicon.
     * RT_XHR ::
     *   XMLHttpRequest.
     * RT_PING ::
     *   A request for a <ping>
     * RT_SERVICE_WORKER ::
     *   Main resource of a service worker.
     * RT_CSP_REPORT ::
     *   A report of Content Security Policy violations.
     * RT_PLUGIN_RESOURCE ::
     *   A resource that a plugin requested.
     * 
     * @method _enum_ResourceType_
     * @return [Symbol]
     * @scope class
     */
    public enum ResourceType implements EnumMapper.IntegerEnum {
        RT_MAIN_FRAME(0),
        RT_SUB_FRAME(1),
        RT_STYLESHEET(2),
        RT_SCRIPT(3),
        RT_IMAGE(4),
        RT_FONT_RESOURCE(5),
        RT_SUB_RESOURCE(6),
        RT_OBJECT(7),
        RT_MEDIA(8),
        RT_WORKER(9),
        RT_SHARED_WORKER(10),
        RT_PREFETCH(11),
        RT_FAVICON(12),
        RT_XHR(13),
        RT_PING(14),
        RT_SERVICE_WORKER(15),
        RT_CSP_REPORT(16),
        RT_PLUGIN_RESOURCE(17)
        ;
        
        private int nativeInt;
        
        private ResourceType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:TransitionType).</em>
     * 
     * === Options:
     * TT_LINK ::
     *   Source is a link click or the JavaScript window.open function. This is
     *   also the default value for requests like sub-resource loads that are not
     *   navigations.
     * TT_EXPLICIT ::
     *   Source is some other "explicit" navigation action such as creating a new
     *   browser or using the LoadURL function. This is also the default value
     *   for navigations where the actual type is unknown.
     * TT_AUTO_SUBFRAME ::
     *   Source is a subframe navigation. This is any content that is automatically
     *   loaded in a non-toplevel frame. For example, if a page consists of several
     *   frames containing ads, those ad URLs will have this transition type.
     *   The user may not even realize the content in these pages is a separate
     *   frame, so may not care about the URL.
     * TT_MANUAL_SUBFRAME ::
     *   Source is a subframe navigation explicitly requested by the user that will
     *   generate new navigation entries in the back/forward list. These are
     *   probably more important than frames that were automatically loaded in
     *   the background because the user probably cares about the fact that this
     *   link was loaded.
     * TT_FORM_SUBMIT ::
     *   Source is a form submission by the user. NOTE: In some situations
     *   submitting a form does not result in this transition type. This can happen
     *   if the form uses a script to submit the contents.
     * TT_RELOAD ::
     *   Source is a "reload" of the page via the Reload function or by re-visiting
     *   the same URL. NOTE: This is distinct from the concept of whether a
     *   particular load uses "reload semantics" (i.e. bypasses cached data).
     * TT_SOURCE_MASK ::
     *   General mask defining the bits used for the source values.
     * TT_BLOCKED_FLAG ::
     *   Attempted to visit a URL but was blocked.
     * TT_FORWARD_BACK_FLAG ::
     *   Used the Forward or Back function to navigate among browsing history.
     * TT_CHAIN_START_FLAG ::
     *   The beginning of a navigation chain.
     * TT_CHAIN_END_FLAG ::
     *   The last transition in a redirect chain.
     * TT_CLIENT_REDIRECT_FLAG ::
     *   Redirects caused by JavaScript or a meta refresh tag on the page.
     * TT_SERVER_REDIRECT_FLAG ::
     *   Redirects sent from the server by HTTP headers.
     * TT_IS_REDIRECT_MASK ::
     *   Used to test whether a transition involves a redirect.
     * TT_QUALIFIER_MASK ::
     *   General mask defining the bits used for the qualifiers.
     * 
     * @method _enum_TransitionType_
     * @return [Symbol]
     * @scope class
     */
    public enum TransitionType implements EnumMapper.IntegerEnum {
        TT_LINK(0),
        TT_EXPLICIT(1),
        TT_AUTO_SUBFRAME(3),
        TT_MANUAL_SUBFRAME(4),
        TT_FORM_SUBMIT(7),
        TT_RELOAD(8),
        TT_SOURCE_MASK(255),
        TT_BLOCKED_FLAG(8388608),
        TT_FORWARD_BACK_FLAG(16777216),
        TT_CHAIN_START_FLAG(268435456),
        TT_CHAIN_END_FLAG(536870912),
        TT_CLIENT_REDIRECT_FLAG(1073741824),
//        TT_SERVER_REDIRECT_FLAG(2147483648),
//        TT_IS_REDIRECT_MASK(3221225472),
//        TT_QUALIFIER_MASK(4294967040)
        ;
        
        private int nativeInt;
        
        private TransitionType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:UrlrequestFlags).</em>
     * 
     * === Options:
     * UR_FLAG_NONE ::
     *   Default behavior.
     * UR_FLAG_SKIP_CACHE ::
     *   If set the cache will be skipped when handling the request.
     * UR_FLAG_ALLOW_CACHED_CREDENTIALS ::
     *   If set user name, password, and cookies may be sent with the request, and
     *   cookies may be saved from the response.
     * UR_FLAG_REPORT_UPLOAD_PROGRESS ::
     *   If set upload progress events will be generated when a request has a body.
     * UR_FLAG_NO_DOWNLOAD_DATA ::
     *   If set the CefURLRequestClient::OnDownloadData method will not be called.
     * UR_FLAG_NO_RETRY_ON_5XX ::
     *   If set 5XX redirect errors will be propagated to the observer instead of
     *   automatically re-tried. This currently only applies for requests
     *   originated in the browser process.
     * 
     * @method _enum_UrlrequestFlags_
     * @return [Symbol]
     * @scope class
     */
    public enum UrlrequestFlags implements EnumMapper.IntegerEnum {
        UR_FLAG_NONE(0),
        UR_FLAG_SKIP_CACHE(1),
        UR_FLAG_ALLOW_CACHED_CREDENTIALS(2),
        UR_FLAG_REPORT_UPLOAD_PROGRESS(8),
        UR_FLAG_NO_DOWNLOAD_DATA(64),
        UR_FLAG_NO_RETRY_ON_5XX(128)
        ;
        
        private int nativeInt;
        
        private UrlrequestFlags(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:UrlrequestStatus).</em>
     * 
     * === Options:
     * UR_UNKNOWN ::
     *   Unknown status.
     * UR_SUCCESS ::
     *   Request succeeded.
     * UR_IO_PENDING ::
     *   An IO request is pending, and the caller will be informed when it is
     *   completed.
     * UR_CANCELED ::
     *   Request was canceled programatically.
     * UR_FAILED ::
     *   Request failed for some reason.
     * 
     * @method _enum_UrlrequestStatus_
     * @return [Symbol]
     * @scope class
     */
    public enum UrlrequestStatus implements EnumMapper.IntegerEnum {
        UR_UNKNOWN(0),
        UR_SUCCESS(1),
        UR_IO_PENDING(2),
        UR_CANCELED(3),
        UR_FAILED(4)
        ;
        
        private int nativeInt;
        
        private UrlrequestStatus(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :x ::
     *   (Integer) 
     * :y ::
     *   (Integer) 
     */
    public static final class Point extends Struct {
        public int x;
        public int y;
        public Point() {
          super(RUNTIME);
        }
        public Point(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :x ::
     *   (Integer) 
     * :y ::
     *   (Integer) 
     * :width ::
     *   (Integer) 
     * :height ::
     *   (Integer) 
     */
    public static final class Rect extends Struct {
        public int x;
        public int y;
        public int width;
        public int height;
        public Rect() {
          super(RUNTIME);
        }
        public Rect(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :width ::
     *   (Integer) 
     * :height ::
     *   (Integer) 
     */
    public static final class Size extends Struct {
        public int width;
        public int height;
        public Size() {
          super(RUNTIME);
        }
        public Size(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :from ::
     *   (Integer) 
     * :to ::
     *   (Integer) 
     */
    public static final class Range extends Struct {
        public int from;
        public int to;
        public Range() {
          super(RUNTIME);
        }
        public Range(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :top ::
     *   (Integer) 
     * :left ::
     *   (Integer) 
     * :bottom ::
     *   (Integer) 
     * :right ::
     *   (Integer) 
     */
    public static final class Insets extends Struct {
        public int top;
        public int left;
        public int bottom;
        public int right;
        public Insets() {
          super(RUNTIME);
        }
        public Insets(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :bounds ::
     *   (Rect) Bounds of the region.
     * :draggable ::
     *   (Integer) True (1) this this region is draggable and false (0) otherwise.
     */
    public static final class DraggableRegion extends Struct {
        public Rect bounds;
        public int draggable;
        public DraggableRegion() {
          super(RUNTIME);
        }
        public DraggableRegion(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ProcessId).</em>
     * 
     * === Options:
     * PID_BROWSER ::
     *   Browser process.
     * PID_RENDERER ::
     *   Renderer process.
     * 
     * @method _enum_ProcessId_
     * @return [Symbol]
     * @scope class
     */
    public enum ProcessId implements EnumMapper.IntegerEnum {
        PID_BROWSER(0),
        PID_RENDERER(1)
        ;
        
        private int nativeInt;
        
        private ProcessId(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ThreadId).</em>
     * 
     * === Options:
     * TID_UI ::
     *   The main thread in the browser. This will be the same as the main
     *   application thread if CefInitialize() is called with a
     *   CefSettings.multi_threaded_message_loop value of false.
     * TID_DB ::
     *   Used to interact with the database.
     * TID_FILE ::
     *   Used to interact with the file system.
     * TID_FILE_USER_BLOCKING ::
     *   Used for file system operations that block user interactions.
     *   Responsiveness of this thread affects users.
     * TID_PROCESS_LAUNCHER ::
     *   Used to launch and terminate browser processes.
     * TID_CACHE ::
     *   Used to handle slow HTTP cache operations.
     * TID_IO ::
     *   Used to process IPC and network messages.
     * TID_RENDERER ::
     *   The main thread in the renderer. Used for all WebKit and V8 interaction.
     * 
     * @method _enum_ThreadId_
     * @return [Symbol]
     * @scope class
     */
    public enum ThreadId implements EnumMapper.IntegerEnum {
        TID_UI(0),
        TID_DB(1),
        TID_FILE(2),
        TID_FILE_USER_BLOCKING(3),
        TID_PROCESS_LAUNCHER(4),
        TID_CACHE(5),
        TID_IO(6),
        TID_RENDERER(7)
        ;
        
        private int nativeInt;
        
        private ThreadId(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ValueType).</em>
     * 
     * === Options:
     * VTYPE_INVALID ::
     *   
     * VTYPE_NULL ::
     *   
     * VTYPE_BOOL ::
     *   
     * VTYPE_INT ::
     *   
     * VTYPE_DOUBLE ::
     *   
     * VTYPE_STRING ::
     *   
     * VTYPE_BINARY ::
     *   
     * VTYPE_DICTIONARY ::
     *   
     * VTYPE_LIST ::
     *   
     * 
     * @method _enum_ValueType_
     * @return [Symbol]
     * @scope class
     */
    public enum ValueType implements EnumMapper.IntegerEnum {
        VTYPE_INVALID(0),
        VTYPE_NULL(1),
        VTYPE_BOOL(2),
        VTYPE_INT(3),
        VTYPE_DOUBLE(4),
        VTYPE_STRING(5),
        VTYPE_BINARY(6),
        VTYPE_DICTIONARY(7),
        VTYPE_LIST(8)
        ;
        
        private int nativeInt;
        
        private ValueType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:JsdialogType).</em>
     * 
     * === Options:
     * JSDIALOGTYPE_ALERT ::
     *   
     * JSDIALOGTYPE_CONFIRM ::
     *   
     * JSDIALOGTYPE_PROMPT ::
     *   
     * 
     * @method _enum_JsdialogType_
     * @return [Symbol]
     * @scope class
     */
    public enum JsdialogType implements EnumMapper.IntegerEnum {
        JSDIALOGTYPE_ALERT(0),
        JSDIALOGTYPE_CONFIRM(1),
        JSDIALOGTYPE_PROMPT(2)
        ;
        
        private int nativeInt;
        
        private JsdialogType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :deviceScaleFactor ::
     *   (Float) Device scale factor. Specifies the ratio between physical and logical
     *   pixels.
     * :depth ::
     *   (Integer) The screen depth in bits per pixel.
     * :depthPerComponent ::
     *   (Integer) The bits per color component. This assumes that the colors are balanced
     *   equally.
     * :isMonochrome ::
     *   (Integer) This can be true for black and white printers.
     * :rect ::
     *   (Rect) This is set from the rcMonitor member of MONITORINFOEX, to whit:
     *     "A RECT structure that specifies the display monitor rectangle,
     *     expressed in virtual-screen coordinates. Note that if the monitor
     *     is not the primary display monitor, some of the rectangle's
     *     coordinates may be negative values."
     *   
     *   The |rect| and |available_rect| properties are used to determine the
     *   available surface for rendering popup views.
     * :availableRect ::
     *   (Rect) This is set from the rcWork member of MONITORINFOEX, to whit:
     *     "A RECT structure that specifies the work area rectangle of the
     *     display monitor that can be used by applications, expressed in
     *     virtual-screen coordinates. Windows uses this rectangle to
     *     maximize an application on the monitor. The rest of the area in
     *     rcMonitor contains system windows such as the task bar and side
     *     bars. Note that if the monitor is not the primary display monitor,
     *     some of the rectangle's coordinates may be negative values".
     *   
     *   The |rect| and |available_rect| properties are used to determine the
     *   available surface for rendering popup views.
     */
    public static final class ScreenInfo extends Struct {
        public float device_scale_factor;
        public int depth;
        public int depth_per_component;
        public int is_monochrome;
        public Rect rect;
        public Rect available_rect;
        public ScreenInfo() {
          super(RUNTIME);
        }
        public ScreenInfo(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:MenuId).</em>
     * 
     * === Options:
     * BACK ::
     *   Navigation.
     * FORWARD ::
     *   
     * RELOAD ::
     *   
     * RELOAD_NOCACHE ::
     *   
     * STOPLOAD ::
     *   
     * UNDO ::
     *   Editing.
     * REDO ::
     *   
     * CUT ::
     *   
     * COPY ::
     *   
     * PASTE ::
     *   
     * DELETE ::
     *   
     * SELECT_ALL ::
     *   
     * FIND ::
     *   Miscellaneous.
     * PRINT ::
     *   
     * VIEW_SOURCE ::
     *   
     * SPELLCHECK_SUGGESTION_0 ::
     *   Spell checking word correction suggestions.
     * SPELLCHECK_SUGGESTION_1 ::
     *   
     * SPELLCHECK_SUGGESTION_2 ::
     *   
     * SPELLCHECK_SUGGESTION_3 ::
     *   
     * SPELLCHECK_SUGGESTION_4 ::
     *   
     * SPELLCHECK_SUGGESTION_LAST ::
     *   
     * NO_SPELLING_SUGGESTIONS ::
     *   
     * ADD_TO_DICTIONARY ::
     *   
     * CUSTOM_FIRST ::
     *   plugin placeholder menu items or Flash menu items.
     * CUSTOM_LAST ::
     *   
     * USER_FIRST ::
     *   defined in the tools/gritsettings/resource_ids file.
     * USER_LAST ::
     *   
     * 
     * @method _enum_MenuId_
     * @return [Symbol]
     * @scope class
     */
    public enum MenuId implements EnumMapper.IntegerEnum {
        BACK(100),
        FORWARD(101),
        RELOAD(102),
        RELOAD_NOCACHE(103),
        STOPLOAD(104),
        UNDO(110),
        REDO(111),
        CUT(112),
        COPY(113),
        PASTE(114),
        DELETE(115),
        SELECT_ALL(116),
        FIND(130),
        PRINT(131),
        VIEW_SOURCE(132),
        SPELLCHECK_SUGGESTION_0(200),
        SPELLCHECK_SUGGESTION_1(201),
        SPELLCHECK_SUGGESTION_2(202),
        SPELLCHECK_SUGGESTION_3(203),
        SPELLCHECK_SUGGESTION_4(204),
        SPELLCHECK_SUGGESTION_LAST(204),
        NO_SPELLING_SUGGESTIONS(205),
        ADD_TO_DICTIONARY(206),
        CUSTOM_FIRST(220),
        CUSTOM_LAST(250),
        USER_FIRST(26500),
        USER_LAST(28500)
        ;
        
        private int nativeInt;
        
        private MenuId(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:MouseButtonType).</em>
     * 
     * === Options:
     * MBT_LEFT ::
     *   
     * MBT_MIDDLE ::
     *   
     * MBT_RIGHT ::
     *   
     * 
     * @method _enum_MouseButtonType_
     * @return [Symbol]
     * @scope class
     */
    public enum MouseButtonType implements EnumMapper.IntegerEnum {
        MBT_LEFT(0),
        MBT_MIDDLE(1),
        MBT_RIGHT(2)
        ;
        
        private int nativeInt;
        
        private MouseButtonType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :x ::
     *   (Integer) X coordinate relative to the left side of the view.
     * :y ::
     *   (Integer) Y coordinate relative to the top side of the view.
     * :modifiers ::
     *   (Integer) Bit flags describing any pressed modifier keys. See
     *   cef_event_flags_t for values.
     */
    public static final class MouseEvent extends Struct {
        public int x;
        public int y;
        public int modifiers;
        public MouseEvent() {
          super(RUNTIME);
        }
        public MouseEvent(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:PaintElementType).</em>
     * 
     * === Options:
     * PET_VIEW ::
     *   
     * PET_POPUP ::
     *   
     * 
     * @method _enum_PaintElementType_
     * @return [Symbol]
     * @scope class
     */
    public enum PaintElementType implements EnumMapper.IntegerEnum {
        PET_VIEW(0),
        PET_POPUP(1)
        ;
        
        private int nativeInt;
        
        private PaintElementType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:EventFlags).</em>
     * 
     * === Options:
     * EVENTFLAG_NONE ::
     *   
     * EVENTFLAG_CAPS_LOCK_ON ::
     *   
     * EVENTFLAG_SHIFT_DOWN ::
     *   
     * EVENTFLAG_CONTROL_DOWN ::
     *   
     * EVENTFLAG_ALT_DOWN ::
     *   
     * EVENTFLAG_LEFT_MOUSE_BUTTON ::
     *   
     * EVENTFLAG_MIDDLE_MOUSE_BUTTON ::
     *   
     * EVENTFLAG_RIGHT_MOUSE_BUTTON ::
     *   
     * EVENTFLAG_COMMAND_DOWN ::
     *   Mac OS-X command key.
     * EVENTFLAG_NUM_LOCK_ON ::
     *   
     * EVENTFLAG_IS_KEY_PAD ::
     *   
     * EVENTFLAG_IS_LEFT ::
     *   
     * EVENTFLAG_IS_RIGHT ::
     *   
     * 
     * @method _enum_EventFlags_
     * @return [Symbol]
     * @scope class
     */
    public enum EventFlags implements EnumMapper.IntegerEnum {
        EVENTFLAG_NONE(0),
        EVENTFLAG_CAPS_LOCK_ON(1),
        EVENTFLAG_SHIFT_DOWN(2),
        EVENTFLAG_CONTROL_DOWN(4),
        EVENTFLAG_ALT_DOWN(8),
        EVENTFLAG_LEFT_MOUSE_BUTTON(16),
        EVENTFLAG_MIDDLE_MOUSE_BUTTON(32),
        EVENTFLAG_RIGHT_MOUSE_BUTTON(64),
        EVENTFLAG_COMMAND_DOWN(128),
        EVENTFLAG_NUM_LOCK_ON(256),
        EVENTFLAG_IS_KEY_PAD(512),
        EVENTFLAG_IS_LEFT(1024),
        EVENTFLAG_IS_RIGHT(2048)
        ;
        
        private int nativeInt;
        
        private EventFlags(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:MenuItemType).</em>
     * 
     * === Options:
     * MENUITEMTYPE_NONE ::
     *   
     * MENUITEMTYPE_COMMAND ::
     *   
     * MENUITEMTYPE_CHECK ::
     *   
     * MENUITEMTYPE_RADIO ::
     *   
     * MENUITEMTYPE_SEPARATOR ::
     *   
     * MENUITEMTYPE_SUBMENU ::
     *   
     * 
     * @method _enum_MenuItemType_
     * @return [Symbol]
     * @scope class
     */
    public enum MenuItemType implements EnumMapper.IntegerEnum {
        MENUITEMTYPE_NONE(0),
        MENUITEMTYPE_COMMAND(1),
        MENUITEMTYPE_CHECK(2),
        MENUITEMTYPE_RADIO(3),
        MENUITEMTYPE_SEPARATOR(4),
        MENUITEMTYPE_SUBMENU(5)
        ;
        
        private int nativeInt;
        
        private MenuItemType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ContextMenuTypeFlags).</em>
     * 
     * === Options:
     * CM_TYPEFLAG_NONE ::
     *   No node is selected.
     * CM_TYPEFLAG_PAGE ::
     *   The top page is selected.
     * CM_TYPEFLAG_FRAME ::
     *   A subframe page is selected.
     * CM_TYPEFLAG_LINK ::
     *   A link is selected.
     * CM_TYPEFLAG_MEDIA ::
     *   A media node is selected.
     * CM_TYPEFLAG_SELECTION ::
     *   There is a textual or mixed selection that is selected.
     * CM_TYPEFLAG_EDITABLE ::
     *   An editable element is selected.
     * 
     * @method _enum_ContextMenuTypeFlags_
     * @return [Symbol]
     * @scope class
     */
    public enum ContextMenuTypeFlags implements EnumMapper.IntegerEnum {
        CM_TYPEFLAG_NONE(0),
        CM_TYPEFLAG_PAGE(1),
        CM_TYPEFLAG_FRAME(2),
        CM_TYPEFLAG_LINK(4),
        CM_TYPEFLAG_MEDIA(8),
        CM_TYPEFLAG_SELECTION(16),
        CM_TYPEFLAG_EDITABLE(32)
        ;
        
        private int nativeInt;
        
        private ContextMenuTypeFlags(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ContextMenuMediaType).</em>
     * 
     * === Options:
     * CM_MEDIATYPE_NONE ::
     *   No special node is in context.
     * CM_MEDIATYPE_IMAGE ::
     *   An image node is selected.
     * CM_MEDIATYPE_VIDEO ::
     *   A video node is selected.
     * CM_MEDIATYPE_AUDIO ::
     *   An audio node is selected.
     * CM_MEDIATYPE_FILE ::
     *   A file node is selected.
     * CM_MEDIATYPE_PLUGIN ::
     *   A plugin node is selected.
     * 
     * @method _enum_ContextMenuMediaType_
     * @return [Symbol]
     * @scope class
     */
    public enum ContextMenuMediaType implements EnumMapper.IntegerEnum {
        CM_MEDIATYPE_NONE(0),
        CM_MEDIATYPE_IMAGE(1),
        CM_MEDIATYPE_VIDEO(2),
        CM_MEDIATYPE_AUDIO(3),
        CM_MEDIATYPE_FILE(4),
        CM_MEDIATYPE_PLUGIN(5)
        ;
        
        private int nativeInt;
        
        private ContextMenuMediaType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ContextMenuMediaStateFlags).</em>
     * 
     * === Options:
     * CM_MEDIAFLAG_NONE ::
     *   
     * CM_MEDIAFLAG_ERROR ::
     *   
     * CM_MEDIAFLAG_PAUSED ::
     *   
     * CM_MEDIAFLAG_MUTED ::
     *   
     * CM_MEDIAFLAG_LOOP ::
     *   
     * CM_MEDIAFLAG_CAN_SAVE ::
     *   
     * CM_MEDIAFLAG_HAS_AUDIO ::
     *   
     * CM_MEDIAFLAG_HAS_VIDEO ::
     *   
     * CM_MEDIAFLAG_CONTROL_ROOT_ELEMENT ::
     *   
     * CM_MEDIAFLAG_CAN_PRINT ::
     *   
     * CM_MEDIAFLAG_CAN_ROTATE ::
     *   
     * 
     * @method _enum_ContextMenuMediaStateFlags_
     * @return [Symbol]
     * @scope class
     */
    public enum ContextMenuMediaStateFlags implements EnumMapper.IntegerEnum {
        CM_MEDIAFLAG_NONE(0),
        CM_MEDIAFLAG_ERROR(1),
        CM_MEDIAFLAG_PAUSED(2),
        CM_MEDIAFLAG_MUTED(4),
        CM_MEDIAFLAG_LOOP(8),
        CM_MEDIAFLAG_CAN_SAVE(16),
        CM_MEDIAFLAG_HAS_AUDIO(32),
        CM_MEDIAFLAG_HAS_VIDEO(64),
        CM_MEDIAFLAG_CONTROL_ROOT_ELEMENT(128),
        CM_MEDIAFLAG_CAN_PRINT(256),
        CM_MEDIAFLAG_CAN_ROTATE(512)
        ;
        
        private int nativeInt;
        
        private ContextMenuMediaStateFlags(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ContextMenuEditStateFlags).</em>
     * 
     * === Options:
     * CM_EDITFLAG_NONE ::
     *   
     * CM_EDITFLAG_CAN_UNDO ::
     *   
     * CM_EDITFLAG_CAN_REDO ::
     *   
     * CM_EDITFLAG_CAN_CUT ::
     *   
     * CM_EDITFLAG_CAN_COPY ::
     *   
     * CM_EDITFLAG_CAN_PASTE ::
     *   
     * CM_EDITFLAG_CAN_DELETE ::
     *   
     * CM_EDITFLAG_CAN_SELECT_ALL ::
     *   
     * CM_EDITFLAG_CAN_TRANSLATE ::
     *   
     * 
     * @method _enum_ContextMenuEditStateFlags_
     * @return [Symbol]
     * @scope class
     */
    public enum ContextMenuEditStateFlags implements EnumMapper.IntegerEnum {
        CM_EDITFLAG_NONE(0),
        CM_EDITFLAG_CAN_UNDO(1),
        CM_EDITFLAG_CAN_REDO(2),
        CM_EDITFLAG_CAN_CUT(4),
        CM_EDITFLAG_CAN_COPY(8),
        CM_EDITFLAG_CAN_PASTE(16),
        CM_EDITFLAG_CAN_DELETE(32),
        CM_EDITFLAG_CAN_SELECT_ALL(64),
        CM_EDITFLAG_CAN_TRANSLATE(128)
        ;
        
        private int nativeInt;
        
        private ContextMenuEditStateFlags(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:KeyEventType).</em>
     * 
     * === Options:
     * KEYEVENT_RAWKEYDOWN ::
     *   Notification that a key transitioned from "up" to "down".
     * KEYEVENT_KEYDOWN ::
     *   Notification that a key was pressed. This does not necessarily correspond
     *   to a character depending on the key and language. Use KEYEVENT_CHAR for
     *   character input.
     * KEYEVENT_KEYUP ::
     *   Notification that a key was released.
     * KEYEVENT_CHAR ::
     *   Notification that a character was typed. Use this for text input. Key
     *   down events may generate 0, 1, or more than one character event depending
     *   on the key, locale, and operating system.
     * 
     * @method _enum_KeyEventType_
     * @return [Symbol]
     * @scope class
     */
    public enum KeyEventType implements EnumMapper.IntegerEnum {
        KEYEVENT_RAWKEYDOWN(0),
        KEYEVENT_KEYDOWN(1),
        KEYEVENT_KEYUP(2),
        KEYEVENT_CHAR(3)
        ;
        
        private int nativeInt;
        
        private KeyEventType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :type ::
     *   (Symbol from _enum_KeyEventType_) The type of keyboard event.
     * :modifiers ::
     *   (Integer) Bit flags describing any pressed modifier keys. See
     *   cef_event_flags_t for values.
     * :windowsKeyCode ::
     *   (Integer) The Windows key code for the key event. This value is used by the DOM
     *   specification. Sometimes it comes directly from the event (i.e. on
     *   Windows) and sometimes it's determined using a mapping function. See
     *   WebCore/platform/chromium/KeyboardCodes.h for the list of values.
     * :nativeKeyCode ::
     *   (Integer) The actual key code genenerated by the platform.
     * :isSystemKey ::
     *   (Integer) Indicates whether the event is considered a "system key" event (see
     *   http://msdn.microsoft.com/en-us/library/ms646286(VS.85).aspx for details).
     *   This value will always be false on non-Windows platforms.
     * :character ::
     *   (Integer) The character generated by the keystroke.
     * :unmodifiedCharacter ::
     *   (Integer) Same as |character| but unmodified by any concurrently-held modifiers
     *   (except shift). This is useful for working out shortcut keys.
     * :focusOnEditableField ::
     *   (Integer) True if the focus is currently on an editable field on the page. This is
     *   useful for determining if standard key events should be intercepted.
     */
    public static final class KeyEvent extends Struct {
        public KeyEventType type;
        public int modifiers;
        public int windows_key_code;
        public int native_key_code;
        public int is_system_key;
        public short character;
        public short unmodified_character;
        public int focus_on_editable_field;
        public KeyEvent() {
          super(RUNTIME);
        }
        public KeyEvent(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:FocusSource).</em>
     * 
     * === Options:
     * NAVIGATION ::
     *   The source is explicit navigation via the API (LoadURL(), etc).
     * SYSTEM ::
     *   The source is a system-generated focus event.
     * 
     * @method _enum_FocusSource_
     * @return [Symbol]
     * @scope class
     */
    public enum FocusSource implements EnumMapper.IntegerEnum {
        NAVIGATION(0),
        SYSTEM(1)
        ;
        
        private int nativeInt;
        
        private FocusSource(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:NavigationType).</em>
     * 
     * === Options:
     * LINK_CLICKED ::
     *   
     * FORM_SUBMITTED ::
     *   
     * BACK_FORWARD ::
     *   
     * RELOAD ::
     *   
     * FORM_RESUBMITTED ::
     *   
     * OTHER ::
     *   
     * 
     * @method _enum_NavigationType_
     * @return [Symbol]
     * @scope class
     */
    public enum NavigationType implements EnumMapper.IntegerEnum {
        LINK_CLICKED(0),
        FORM_SUBMITTED(1),
        BACK_FORWARD(2),
        RELOAD(3),
        FORM_RESUBMITTED(4),
        OTHER(5)
        ;
        
        private int nativeInt;
        
        private NavigationType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:XmlEncodingType).</em>
     * 
     * === Options:
     * NONE ::
     *   
     * UTF8 ::
     *   
     * UTF16LE ::
     *   
     * UTF16BE ::
     *   
     * ASCII ::
     *   
     * 
     * @method _enum_XmlEncodingType_
     * @return [Symbol]
     * @scope class
     */
    public enum XmlEncodingType implements EnumMapper.IntegerEnum {
        NONE(0),
        UTF8(1),
        UTF16LE(2),
        UTF16BE(3),
        ASCII(4)
        ;
        
        private int nativeInt;
        
        private XmlEncodingType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:XmlNodeType).</em>
     * 
     * === Options:
     * UNSUPPORTED ::
     *   
     * PROCESSING_INSTRUCTION ::
     *   
     * DOCUMENT_TYPE ::
     *   
     * ELEMENT_START ::
     *   
     * ELEMENT_END ::
     *   
     * ATTRIBUTE ::
     *   
     * TEXT ::
     *   
     * CDATA ::
     *   
     * ENTITY_REFERENCE ::
     *   
     * WHITESPACE ::
     *   
     * COMMENT ::
     *   
     * 
     * @method _enum_XmlNodeType_
     * @return [Symbol]
     * @scope class
     */
    public enum XmlNodeType implements EnumMapper.IntegerEnum {
        UNSUPPORTED(0),
        PROCESSING_INSTRUCTION(1),
        DOCUMENT_TYPE(2),
        ELEMENT_START(3),
        ELEMENT_END(4),
        ATTRIBUTE(5),
        TEXT(6),
        CDATA(7),
        ENTITY_REFERENCE(8),
        WHITESPACE(9),
        COMMENT(10)
        ;
        
        private int nativeInt;
        
        private XmlNodeType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :x ::
     *   (Integer) 
     * :xSet ::
     *   (Integer) 
     * :y ::
     *   (Integer) 
     * :ySet ::
     *   (Integer) 
     * :width ::
     *   (Integer) 
     * :widthSet ::
     *   (Integer) 
     * :height ::
     *   (Integer) 
     * :heightSet ::
     *   (Integer) 
     * :menuBarVisible ::
     *   (Integer) 
     * :statusBarVisible ::
     *   (Integer) 
     * :toolBarVisible ::
     *   (Integer) 
     * :locationBarVisible ::
     *   (Integer) 
     * :scrollbarsVisible ::
     *   (Integer) 
     * :resizable ::
     *   (Integer) 
     * :fullscreen ::
     *   (Integer) 
     * :dialog ::
     *   (Integer) 
     * :additionalFeatures ::
     *   (FFI::Pointer(StringList)) 
     */
    public static final class PopupFeatures extends Struct {
        public int x;
        public int xSet;
        public int y;
        public int ySet;
        public int width;
        public int widthSet;
        public int height;
        public int heightSet;
        public int menuBarVisible;
        public int statusBarVisible;
        public int toolBarVisible;
        public int locationBarVisible;
        public int scrollbarsVisible;
        public int resizable;
        public int fullscreen;
        public int dialog;
        public Pointer additionalFeatures;
        public PopupFeatures() {
          super(RUNTIME);
        }
        public PopupFeatures(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:DomDocumentType).</em>
     * 
     * === Options:
     * UNKNOWN ::
     *   
     * HTML ::
     *   
     * XHTML ::
     *   
     * PLUGIN ::
     *   
     * 
     * @method _enum_DomDocumentType_
     * @return [Symbol]
     * @scope class
     */
    public enum DomDocumentType implements EnumMapper.IntegerEnum {
        UNKNOWN(0),
        HTML(1),
        XHTML(2),
        PLUGIN(3)
        ;
        
        private int nativeInt;
        
        private DomDocumentType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:DomEventCategory).</em>
     * 
     * === Options:
     * UNKNOWN ::
     *   
     * UI ::
     *   
     * MOUSE ::
     *   
     * MUTATION ::
     *   
     * KEYBOARD ::
     *   
     * TEXT ::
     *   
     * COMPOSITION ::
     *   
     * DRAG ::
     *   
     * CLIPBOARD ::
     *   
     * MESSAGE ::
     *   
     * WHEEL ::
     *   
     * BEFORE_TEXT_INSERTED ::
     *   
     * OVERFLOW ::
     *   
     * PAGE_TRANSITION ::
     *   
     * POPSTATE ::
     *   
     * PROGRESS ::
     *   
     * XMLHTTPREQUEST_PROGRESS ::
     *   
     * 
     * @method _enum_DomEventCategory_
     * @return [Symbol]
     * @scope class
     */
    public enum DomEventCategory implements EnumMapper.IntegerEnum {
        UNKNOWN(0),
        UI(1),
        MOUSE(2),
        MUTATION(4),
        KEYBOARD(8),
        TEXT(16),
        COMPOSITION(32),
        DRAG(64),
        CLIPBOARD(128),
        MESSAGE(256),
        WHEEL(512),
        BEFORE_TEXT_INSERTED(1024),
        OVERFLOW(2048),
        PAGE_TRANSITION(4096),
        POPSTATE(8192),
        PROGRESS(16384),
        XMLHTTPREQUEST_PROGRESS(32768)
        ;
        
        private int nativeInt;
        
        private DomEventCategory(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:DomEventPhase).</em>
     * 
     * === Options:
     * UNKNOWN ::
     *   
     * CAPTURING ::
     *   
     * AT_TARGET ::
     *   
     * BUBBLING ::
     *   
     * 
     * @method _enum_DomEventPhase_
     * @return [Symbol]
     * @scope class
     */
    public enum DomEventPhase implements EnumMapper.IntegerEnum {
        UNKNOWN(0),
        CAPTURING(1),
        AT_TARGET(2),
        BUBBLING(3)
        ;
        
        private int nativeInt;
        
        private DomEventPhase(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:DomNodeType).</em>
     * 
     * === Options:
     * UNSUPPORTED ::
     *   
     * ELEMENT ::
     *   
     * ATTRIBUTE ::
     *   
     * TEXT ::
     *   
     * CDATA_SECTION ::
     *   
     * PROCESSING_INSTRUCTIONS ::
     *   
     * COMMENT ::
     *   
     * DOCUMENT ::
     *   
     * DOCUMENT_TYPE ::
     *   
     * DOCUMENT_FRAGMENT ::
     *   
     * 
     * @method _enum_DomNodeType_
     * @return [Symbol]
     * @scope class
     */
    public enum DomNodeType implements EnumMapper.IntegerEnum {
        UNSUPPORTED(0),
        ELEMENT(1),
        ATTRIBUTE(2),
        TEXT(3),
        CDATA_SECTION(4),
        PROCESSING_INSTRUCTIONS(5),
        COMMENT(6),
        DOCUMENT(7),
        DOCUMENT_TYPE(8),
        DOCUMENT_FRAGMENT(9)
        ;
        
        private int nativeInt;
        
        private DomNodeType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:FileDialogMode).</em>
     * 
     * === Options:
     * OPEN ::
     *   Requires that the file exists before allowing the user to pick it.
     * OPEN_MULTIPLE ::
     *   Like Open, but allows picking multiple files to open.
     * OPEN_FOLDER ::
     *   Like Open, but selects a folder to open.
     * SAVE ::
     *   Allows picking a nonexistent file, and prompts to overwrite if the file
     *   already exists.
     * TYPE_MASK ::
     *   General mask defining the bits used for the type values.
     * OVERWRITEPROMPT_FLAG ::
     *   Prompt to overwrite if the user selects an existing file with the Save
     *   dialog.
     * HIDEREADONLY_FLAG ::
     *   Do not display read-only files.
     * 
     * @method _enum_FileDialogMode_
     * @return [Symbol]
     * @scope class
     */
    public enum FileDialogMode implements EnumMapper.IntegerEnum {
        OPEN(0),
        OPEN_MULTIPLE(1),
        OPEN_FOLDER(2),
        SAVE(3),
        TYPE_MASK(255),
        OVERWRITEPROMPT_FLAG(16777216),
        HIDEREADONLY_FLAG(33554432)
        ;
        
        private int nativeInt;
        
        private FileDialogMode(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:GeopositionErrorCode).</em>
     * 
     * === Options:
     * GEOPOSITON_ERROR_NONE ::
     *   
     * GEOPOSITON_ERROR_PERMISSION_DENIED ::
     *   
     * GEOPOSITON_ERROR_POSITION_UNAVAILABLE ::
     *   
     * GEOPOSITON_ERROR_TIMEOUT ::
     *   
     * 
     * @method _enum_GeopositionErrorCode_
     * @return [Symbol]
     * @scope class
     */
    public enum GeopositionErrorCode implements EnumMapper.IntegerEnum {
        GEOPOSITON_ERROR_NONE(0),
        GEOPOSITON_ERROR_PERMISSION_DENIED(1),
        GEOPOSITON_ERROR_POSITION_UNAVAILABLE(2),
        GEOPOSITON_ERROR_TIMEOUT(3)
        ;
        
        private int nativeInt;
        
        private GeopositionErrorCode(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :latitude ::
     *   (Float) Latitude in decimal degrees north (WGS84 coordinate frame).
     * :longitude ::
     *   (Float) Longitude in decimal degrees west (WGS84 coordinate frame).
     * :altitude ::
     *   (Float) Altitude in meters (above WGS84 datum).
     * :accuracy ::
     *   (Float) Accuracy of horizontal position in meters.
     * :altitudeAccuracy ::
     *   (Float) Accuracy of altitude in meters.
     * :heading ::
     *   (Float) Heading in decimal degrees clockwise from true north.
     * :speed ::
     *   (Float) Horizontal component of device velocity in meters per second.
     * :timestamp ::
     *   (unknown) Time of position measurement in milliseconds since Epoch in UTC time. This
     *   is taken from the host computer's system clock.
     * :errorCode ::
     *   (Symbol from _enum_GeopositionErrorCode_) Error code, see enum above.
     * :errorMessage ::
     *   (StringUtf16) Human-readable error message.
     */
    public static final class Geoposition extends Struct {
        public double latitude;
        public double longitude;
        public double altitude;
        public double accuracy;
        public double altitude_accuracy;
        public double heading;
        public double speed;
        public byte timestamp;
        public GeopositionErrorCode error_code;
        public StringUtf16 error_message;
        public Geoposition() {
          super(RUNTIME);
        }
        public Geoposition(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ColorModel).</em>
     * 
     * === Options:
     * UNKNOWN ::
     *   
     * GRAY ::
     *   
     * COLOR ::
     *   
     * CMYK ::
     *   
     * CMY ::
     *   
     * KCMY ::
     *   
     * CMY_K ::
     *   
     * BLACK ::
     *   CMY_K represents CMY+K.
     * GRAYSCALE ::
     *   
     * RGB ::
     *   
     * RGB16 ::
     *   
     * RGBA ::
     *   
     * COLORMODE_COLOR ::
     *   
     * COLORMODE_MONOCHROME ::
     *   Used in samsung printer ppds.
     * HP_COLOR_COLOR ::
     *   Used in samsung printer ppds.
     * HP_COLOR_BLACK ::
     *   Used in HP color printer ppds.
     * PRINTOUTMODE_NORMAL ::
     *   Used in HP color printer ppds.
     * PRINTOUTMODE_NORMAL_GRAY ::
     *   Used in foomatic ppds.
     * PROCESSCOLORMODEL_CMYK ::
     *   Used in foomatic ppds.
     * PROCESSCOLORMODEL_GREYSCALE ::
     *   Used in canon printer ppds.
     * PROCESSCOLORMODEL_RGB ::
     *   Used in canon printer ppds.
     * 
     * @method _enum_ColorModel_
     * @return [Symbol]
     * @scope class
     */
    public enum ColorModel implements EnumMapper.IntegerEnum {
        UNKNOWN(0),
        GRAY(1),
        COLOR(2),
        CMYK(3),
        CMY(4),
        KCMY(5),
        CMY_K(6),
        BLACK(7),
        GRAYSCALE(8),
        RGB(9),
        RGB16(10),
        RGBA(11),
        COLORMODE_COLOR(12),
        COLORMODE_MONOCHROME(13),
        HP_COLOR_COLOR(14),
        HP_COLOR_BLACK(15),
        PRINTOUTMODE_NORMAL(16),
        PRINTOUTMODE_NORMAL_GRAY(17),
        PROCESSCOLORMODEL_CMYK(18),
        PROCESSCOLORMODEL_GREYSCALE(19),
        PROCESSCOLORMODEL_RGB(20)
        ;
        
        private int nativeInt;
        
        private ColorModel(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:DuplexMode).</em>
     * 
     * === Options:
     * UNKNOWN ::
     *   
     * SIMPLEX ::
     *   
     * LONG_EDGE ::
     *   
     * SHORT_EDGE ::
     *   
     * 
     * @method _enum_DuplexMode_
     * @return [Symbol]
     * @scope class
     */
    public enum DuplexMode implements EnumMapper.IntegerEnum {
        UNKNOWN(-1),
        SIMPLEX(0),
        LONG_EDGE(1),
        SHORT_EDGE(2)
        ;
        
        private int nativeInt;
        
        private DuplexMode(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:CursorType).</em>
     * 
     * === Options:
     * CT_POINTER ::
     *   
     * CT_CROSS ::
     *   
     * CT_HAND ::
     *   
     * CT_IBEAM ::
     *   
     * CT_WAIT ::
     *   
     * CT_HELP ::
     *   
     * CT_EASTRESIZE ::
     *   
     * CT_NORTHRESIZE ::
     *   
     * CT_NORTHEASTRESIZE ::
     *   
     * CT_NORTHWESTRESIZE ::
     *   
     * CT_SOUTHRESIZE ::
     *   
     * CT_SOUTHEASTRESIZE ::
     *   
     * CT_SOUTHWESTRESIZE ::
     *   
     * CT_WESTRESIZE ::
     *   
     * CT_NORTHSOUTHRESIZE ::
     *   
     * CT_EASTWESTRESIZE ::
     *   
     * CT_NORTHEASTSOUTHWESTRESIZE ::
     *   
     * CT_NORTHWESTSOUTHEASTRESIZE ::
     *   
     * CT_COLUMNRESIZE ::
     *   
     * CT_ROWRESIZE ::
     *   
     * CT_MIDDLEPANNING ::
     *   
     * CT_EASTPANNING ::
     *   
     * CT_NORTHPANNING ::
     *   
     * CT_NORTHEASTPANNING ::
     *   
     * CT_NORTHWESTPANNING ::
     *   
     * CT_SOUTHPANNING ::
     *   
     * CT_SOUTHEASTPANNING ::
     *   
     * CT_SOUTHWESTPANNING ::
     *   
     * CT_WESTPANNING ::
     *   
     * CT_MOVE ::
     *   
     * CT_VERTICALTEXT ::
     *   
     * CT_CELL ::
     *   
     * CT_CONTEXTMENU ::
     *   
     * CT_ALIAS ::
     *   
     * CT_PROGRESS ::
     *   
     * CT_NODROP ::
     *   
     * CT_COPY ::
     *   
     * CT_NONE ::
     *   
     * CT_NOTALLOWED ::
     *   
     * CT_ZOOMIN ::
     *   
     * CT_ZOOMOUT ::
     *   
     * CT_GRAB ::
     *   
     * CT_GRABBING ::
     *   
     * CT_CUSTOM ::
     *   
     * 
     * @method _enum_CursorType_
     * @return [Symbol]
     * @scope class
     */
    public enum CursorType implements EnumMapper.IntegerEnum {
        CT_POINTER(0),
        CT_CROSS(1),
        CT_HAND(2),
        CT_IBEAM(3),
        CT_WAIT(4),
        CT_HELP(5),
        CT_EASTRESIZE(6),
        CT_NORTHRESIZE(7),
        CT_NORTHEASTRESIZE(8),
        CT_NORTHWESTRESIZE(9),
        CT_SOUTHRESIZE(10),
        CT_SOUTHEASTRESIZE(11),
        CT_SOUTHWESTRESIZE(12),
        CT_WESTRESIZE(13),
        CT_NORTHSOUTHRESIZE(14),
        CT_EASTWESTRESIZE(15),
        CT_NORTHEASTSOUTHWESTRESIZE(16),
        CT_NORTHWESTSOUTHEASTRESIZE(17),
        CT_COLUMNRESIZE(18),
        CT_ROWRESIZE(19),
        CT_MIDDLEPANNING(20),
        CT_EASTPANNING(21),
        CT_NORTHPANNING(22),
        CT_NORTHEASTPANNING(23),
        CT_NORTHWESTPANNING(24),
        CT_SOUTHPANNING(25),
        CT_SOUTHEASTPANNING(26),
        CT_SOUTHWESTPANNING(27),
        CT_WESTPANNING(28),
        CT_MOVE(29),
        CT_VERTICALTEXT(30),
        CT_CELL(31),
        CT_CONTEXTMENU(32),
        CT_ALIAS(33),
        CT_PROGRESS(34),
        CT_NODROP(35),
        CT_COPY(36),
        CT_NONE(37),
        CT_NOTALLOWED(38),
        CT_ZOOMIN(39),
        CT_ZOOMOUT(40),
        CT_GRAB(41),
        CT_GRABBING(42),
        CT_CUSTOM(43)
        ;
        
        private int nativeInt;
        
        private CursorType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :hotspot ::
     *   (Point) 
     * :imageScaleFactor ::
     *   (Float) 
     * :buffer ::
     *   (FFI::Pointer(*Void)) 
     * :size ::
     *   (Size) 
     */
    public static final class CursorInfo extends Struct {
        public Point hotspot;
        public float image_scale_factor;
        public Pointer buffer;
        public Size size;
        public CursorInfo() {
          super(RUNTIME);
        }
        public CursorInfo(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:UriUnescapeRule).</em>
     * 
     * === Options:
     * UU_NONE ::
     *   Don't unescape anything at all.
     * UU_NORMAL ::
     *   Don't unescape anything special, but all normal unescaping will happen.
     *   This is a placeholder and can't be combined with other flags (since it's
     *   just the absence of them). All other unescape rules imply "normal" in
     *   addition to their special meaning. Things like escaped letters, digits,
     *   and most symbols will get unescaped with this mode.
     * UU_SPACES ::
     *   Convert %20 to spaces. In some places where we're showing URLs, we may
     *   want this. In places where the URL may be copied and pasted out, then
     *   you wouldn't want this since it might not be interpreted in one piece
     *   by other applications.
     * UU_PATH_SEPARATORS ::
     *   Unescapes '/' and '\\'. If these characters were unescaped, the resulting
     *   URL won't be the same as the source one. Moreover, they are dangerous to
     *   unescape in strings that will be used as file paths or names. This value
     *   should only be used when slashes don't have special meaning, like data
     *   URLs.
     * UU_URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS ::
     *   Unescapes various characters that will change the meaning of URLs,
     *   including '%', '+', '&', '#'. Does not unescape path separators.
     *   If these characters were unescaped, the resulting URL won't be the same
     *   as the source one. This flag is used when generating final output like
     *   filenames for URLs where we won't be interpreting as a URL and want to do
     *   as much unescaping as possible.
     * UU_SPOOFING_AND_CONTROL_CHARS ::
     *   Unescapes characters that can be used in spoofing attempts (such as LOCK)
     *   and control characters (such as BiDi control characters and %01).  This
     *   INCLUDES NULLs.  This is used for rare cases such as data: URL decoding
     *   where the result is binary data.
     *   
     *   DO NOT use UU_SPOOFING_AND_CONTROL_CHARS if the URL is going to be
     *   displayed in the UI for security reasons.
     * UU_REPLACE_PLUS_WITH_SPACE ::
     *   URL queries use "+" for space. This flag controls that replacement.
     * 
     * @method _enum_UriUnescapeRule_
     * @return [Symbol]
     * @scope class
     */
    public enum UriUnescapeRule implements EnumMapper.IntegerEnum {
        UU_NONE(0),
        UU_NORMAL(1),
        UU_SPACES(2),
        UU_PATH_SEPARATORS(4),
        UU_URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS(8),
        UU_SPOOFING_AND_CONTROL_CHARS(16),
        UU_REPLACE_PLUS_WITH_SPACE(32)
        ;
        
        private int nativeInt;
        
        private UriUnescapeRule(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:JsonParserOptions).</em>
     * 
     * === Options:
     * RFC ::
     *   Parses the input strictly according to RFC 4627. See comments in Chromium's
     *   base/json/json_reader.h file for known limitations/deviations from the RFC.
     * ALLOW_TRAILING_COMMAS ::
     *   Allows commas to exist after the last element in structures.
     * 
     * @method _enum_JsonParserOptions_
     * @return [Symbol]
     * @scope class
     */
    public enum JsonParserOptions implements EnumMapper.IntegerEnum {
        RFC(0),
        ALLOW_TRAILING_COMMAS(1)
        ;
        
        private int nativeInt;
        
        private JsonParserOptions(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:JsonParserError).</em>
     * 
     * === Options:
     * NO_ERROR ::
     *   
     * INVALID_ESCAPE ::
     *   
     * SYNTAX_ERROR ::
     *   
     * UNEXPECTED_TOKEN ::
     *   
     * TRAILING_COMMA ::
     *   
     * TOO_MUCH_NESTING ::
     *   
     * UNEXPECTED_DATA_AFTER_ROOT ::
     *   
     * UNSUPPORTED_ENCODING ::
     *   
     * UNQUOTED_DICTIONARY_KEY ::
     *   
     * PARSE_ERROR_COUNT ::
     *   
     * 
     * @method _enum_JsonParserError_
     * @return [Symbol]
     * @scope class
     */
    public enum JsonParserError implements EnumMapper.IntegerEnum {
        NO_ERROR(0),
        INVALID_ESCAPE(1),
        SYNTAX_ERROR(2),
        UNEXPECTED_TOKEN(3),
        TRAILING_COMMA(4),
        TOO_MUCH_NESTING(5),
        UNEXPECTED_DATA_AFTER_ROOT(6),
        UNSUPPORTED_ENCODING(7),
        UNQUOTED_DICTIONARY_KEY(8),
        PARSE_ERROR_COUNT(9)
        ;
        
        private int nativeInt;
        
        private JsonParserError(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:JsonWriterOptions).</em>
     * 
     * === Options:
     * DEFAULT ::
     *   Default behavior.
     * OMIT_BINARY_VALUES ::
     *   This option instructs the writer that if a Binary value is encountered,
     *   the value (and key if within a dictionary) will be omitted from the
     *   output, and success will be returned. Otherwise, if a binary value is
     *   encountered, failure will be returned.
     * OMIT_DOUBLE_TYPE_PRESERVATION ::
     *   This option instructs the writer to write doubles that have no fractional
     *   part as a normal integer (i.e., without using exponential notation
     *   or appending a '.0') as long as the value is within the range of a
     *   64-bit int.
     * PRETTY_PRINT ::
     *   Return a slightly nicer formatted json string (pads with whitespace to
     *   help with readability).
     * 
     * @method _enum_JsonWriterOptions_
     * @return [Symbol]
     * @scope class
     */
    public enum JsonWriterOptions implements EnumMapper.IntegerEnum {
        DEFAULT(0),
        OMIT_BINARY_VALUES(1),
        OMIT_DOUBLE_TYPE_PRESERVATION(2),
        PRETTY_PRINT(4)
        ;
        
        private int nativeInt;
        
        private JsonWriterOptions(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:PdfPrintMarginType).</em>
     * 
     * === Options:
     * DEFAULT ::
     *   Default margins.
     * NONE ::
     *   No margins.
     * MINIMUM ::
     *   Minimum margins.
     * CUSTOM ::
     *   Custom margins using the |margin_*| values from cef_pdf_print_settings_t.
     * 
     * @method _enum_PdfPrintMarginType_
     * @return [Symbol]
     * @scope class
     */
    public enum PdfPrintMarginType implements EnumMapper.IntegerEnum {
        DEFAULT(0),
        NONE(1),
        MINIMUM(2),
        CUSTOM(3)
        ;
        
        private int nativeInt;
        
        private PdfPrintMarginType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :headerFooterTitle ::
     *   (StringUtf16) Page title to display in the header. Only used if |header_footer_enabled|
     *   is set to true (1).
     * :headerFooterUrl ::
     *   (StringUtf16) URL to display in the footer. Only used if |header_footer_enabled| is set
     *   to true (1).
     * :pageWidth ::
     *   (Integer) Output page size in microns. If either of these values is less than or
     *   equal to zero then the default paper size (A4) will be used.
     * :pageHeight ::
     *   (Integer) 
     * :marginTop ::
     *   (Float) Margins in millimeters. Only used if |margin_type| is set to
     *   PDF_PRINT_MARGIN_CUSTOM.
     * :marginRight ::
     *   (Float) 
     * :marginBottom ::
     *   (Float) 
     * :marginLeft ::
     *   (Float) 
     * :marginType ::
     *   (Symbol from _enum_PdfPrintMarginType_) Margin type.
     * :headerFooterEnabled ::
     *   (Integer) Set to true (1) to print headers and footers or false (0) to not print
     *   headers and footers.
     * :selectionOnly ::
     *   (Integer) Set to true (1) to print the selection only or false (0) to print all.
     * :landscape ::
     *   (Integer) Set to true (1) for landscape mode or false (0) for portrait mode.
     * :backgroundsEnabled ::
     *   (Integer) Set to true (1) to print background graphics or false (0) to not print
     *   background graphics.
     */
    public static final class PdfPrintSettings extends Struct {
        public StringUtf16 header_footer_title;
        public StringUtf16 header_footer_url;
        public int page_width;
        public int page_height;
        public double margin_top;
        public double margin_right;
        public double margin_bottom;
        public double margin_left;
        public PdfPrintMarginType margin_type;
        public int header_footer_enabled;
        public int selection_only;
        public int landscape;
        public int backgrounds_enabled;
        public PdfPrintSettings() {
          super(RUNTIME);
        }
        public PdfPrintSettings(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ScaleFactor).</em>
     * 
     * === Options:
     * NONE ::
     *   
     * _100P ::
     *   
     * _125P ::
     *   
     * _133P ::
     *   
     * _140P ::
     *   
     * _150P ::
     *   
     * _180P ::
     *   
     * _200P ::
     *   
     * _250P ::
     *   
     * _300P ::
     *   
     * 
     * @method _enum_ScaleFactor_
     * @return [Symbol]
     * @scope class
     */
    public enum ScaleFactor implements EnumMapper.IntegerEnum {
        NONE(0),
        _100P(1),
        _125P(2),
        _133P(3),
        _140P(4),
        _150P(5),
        _180P(6),
        _200P(7),
        _250P(8),
        _300P(9)
        ;
        
        private int nativeInt;
        
        private ScaleFactor(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:PluginPolicy).</em>
     * 
     * === Options:
     * ALLOW ::
     *   Allow the content.
     * DETECT_IMPORTANT ::
     *   Allow important content and block unimportant content based on heuristics.
     *   The user can manually load blocked content.
     * BLOCK ::
     *   Block the content. The user can manually load blocked content.
     * DISABLE ::
     *   Disable the content. The user cannot load disabled content.
     * 
     * @method _enum_PluginPolicy_
     * @return [Symbol]
     * @scope class
     */
    public enum PluginPolicy implements EnumMapper.IntegerEnum {
        ALLOW(0),
        DETECT_IMPORTANT(1),
        BLOCK(2),
        DISABLE(3)
        ;
        
        private int nativeInt;
        
        private PluginPolicy(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ReferrerPolicy).</em>
     * 
     * === Options:
     * ALWAYS ::
     *   Always send the complete Referrer value.
     * DEFAULT ::
     *   Use the default policy. This is REFERRER_POLICY_ORIGIN_WHEN_CROSS_ORIGIN
     *   when the `--reduced-referrer-granularity` command-line flag is specified
     *   and REFERRER_POLICY_NO_REFERRER_WHEN_DOWNGRADE otherwise.
     * NO_REFERRER_WHEN_DOWNGRADE ::
     *   When navigating from HTTPS to HTTP do not send the Referrer value.
     *   Otherwise, send the complete Referrer value.
     * NEVER ::
     *   Never send the Referrer value.
     * ORIGIN ::
     *   Only send the origin component of the Referrer value.
     * ORIGIN_WHEN_CROSS_ORIGIN ::
     *   When navigating cross-origin only send the origin component of the Referrer
     *   value. Otherwise, send the complete Referrer value.
     * 
     * @method _enum_ReferrerPolicy_
     * @return [Symbol]
     * @scope class
     */
    public enum ReferrerPolicy implements EnumMapper.IntegerEnum {
        ALWAYS(0),
        DEFAULT(1),
        NO_REFERRER_WHEN_DOWNGRADE(2),
        NEVER(3),
        ORIGIN(4),
        ORIGIN_WHEN_CROSS_ORIGIN(5)
        ;
        
        private int nativeInt;
        
        private ReferrerPolicy(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ResponseFilterStatus).</em>
     * 
     * === Options:
     * NEED_MORE_DATA ::
     *   Some or all of the pre-filter data was read successfully but more data is
     *   needed in order to continue filtering (filtered output is pending).
     * DONE ::
     *   Some or all of the pre-filter data was read successfully and all available
     *   filtered output has been written.
     * ERROR ::
     *   An error occurred during filtering.
     * 
     * @method _enum_ResponseFilterStatus_
     * @return [Symbol]
     * @scope class
     */
    public enum ResponseFilterStatus implements EnumMapper.IntegerEnum {
        NEED_MORE_DATA(0),
        DONE(1),
        ERROR(2)
        ;
        
        private int nativeInt;
        
        private ResponseFilterStatus(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ColorType).</em>
     * 
     * === Options:
     * RGBA_8888 ::
     *   RGBA with 8 bits per pixel (32bits total).
     * BGRA_8888 ::
     *   BGRA with 8 bits per pixel (32bits total).
     * 
     * @method _enum_ColorType_
     * @return [Symbol]
     * @scope class
     */
    public enum ColorType implements EnumMapper.IntegerEnum {
        RGBA_8888(0),
        BGRA_8888(1)
        ;
        
        private int nativeInt;
        
        private ColorType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:AlphaType).</em>
     * 
     * === Options:
     * OPAQUE ::
     *   No transparency. The alpha component is ignored.
     * PREMULTIPLIED ::
     *   Transparency with pre-multiplied alpha component.
     * POSTMULTIPLIED ::
     *   Transparency with post-multiplied alpha component.
     * 
     * @method _enum_AlphaType_
     * @return [Symbol]
     * @scope class
     */
    public enum AlphaType implements EnumMapper.IntegerEnum {
        OPAQUE(0),
        PREMULTIPLIED(1),
        POSTMULTIPLIED(2)
        ;
        
        private int nativeInt;
        
        private AlphaType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:TextStyle).</em>
     * 
     * === Options:
     * BOLD ::
     *   
     * ITALIC ::
     *   
     * STRIKE ::
     *   
     * DIAGONAL_STRIKE ::
     *   
     * UNDERLINE ::
     *   
     * 
     * @method _enum_TextStyle_
     * @return [Symbol]
     * @scope class
     */
    public enum TextStyle implements EnumMapper.IntegerEnum {
        BOLD(0),
        ITALIC(1),
        STRIKE(2),
        DIAGONAL_STRIKE(3),
        UNDERLINE(4)
        ;
        
        private int nativeInt;
        
        private TextStyle(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:MainAxisAlignment).</em>
     * 
     * === Options:
     * START ::
     *   Child views will be left-aligned.
     * CENTER ::
     *   Child views will be center-aligned.
     * END ::
     *   Child views will be right-aligned.
     * 
     * @method _enum_MainAxisAlignment_
     * @return [Symbol]
     * @scope class
     */
    public enum MainAxisAlignment implements EnumMapper.IntegerEnum {
        START(0),
        CENTER(1),
        END(2)
        ;
        
        private int nativeInt;
        
        private MainAxisAlignment(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:CrossAxisAlignment).</em>
     * 
     * === Options:
     * STRETCH ::
     *   Child views will be stretched to fit.
     * START ::
     *   Child views will be left-aligned.
     * CENTER ::
     *   Child views will be center-aligned.
     * END ::
     *   Child views will be right-aligned.
     * 
     * @method _enum_CrossAxisAlignment_
     * @return [Symbol]
     * @scope class
     */
    public enum CrossAxisAlignment implements EnumMapper.IntegerEnum {
        STRETCH(0),
        START(1),
        CENTER(2),
        END(3)
        ;
        
        private int nativeInt;
        
        private CrossAxisAlignment(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :horizontal ::
     *   (Integer) If true (1) the layout will be horizontal, otherwise the layout will be
     *   vertical.
     * :insideBorderHorizontalSpacing ::
     *   (Integer) Adds additional horizontal space between the child view area and the host
     *   view border.
     * :insideBorderVerticalSpacing ::
     *   (Integer) Adds additional vertical space between the child view area and the host
     *   view border.
     * :insideBorderInsets ::
     *   (Insets) Adds additional space around the child view area.
     * :betweenChildSpacing ::
     *   (Integer) Adds additional space between child views.
     * :mainAxisAlignment ::
     *   (Symbol from _enum_MainAxisAlignment_) Specifies where along the main axis the child views should be laid out.
     * :crossAxisAlignment ::
     *   (Symbol from _enum_CrossAxisAlignment_) Specifies where along the cross axis the child views should be laid out.
     * :minimumCrossAxisSize ::
     *   (Integer) Minimum cross axis size.
     * :defaultFlex ::
     *   (Integer) Default flex for views when none is specified via CefBoxLayout methods.
     *   Using the preferred size as the basis, free space along the main axis is
     *   distributed to views in the ratio of their flex weights. Similarly, if the
     *   views will overflow the parent, space is subtracted in these ratios. A flex
     *   of 0 means this view is not resized. Flex values must not be negative.
     */
    public static final class BoxLayoutSettings extends Struct {
        public int horizontal;
        public int inside_border_horizontal_spacing;
        public int inside_border_vertical_spacing;
        public Insets inside_border_insets;
        public int between_child_spacing;
        public MainAxisAlignment main_axis_alignment;
        public CrossAxisAlignment cross_axis_alignment;
        public int minimum_cross_axis_size;
        public int default_flex;
        public BoxLayoutSettings() {
          super(RUNTIME);
        }
        public BoxLayoutSettings(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ButtonState).</em>
     * 
     * === Options:
     * NORMAL ::
     *   
     * HOVERED ::
     *   
     * PRESSED ::
     *   
     * DISABLED ::
     *   
     * 
     * @method _enum_ButtonState_
     * @return [Symbol]
     * @scope class
     */
    public enum ButtonState implements EnumMapper.IntegerEnum {
        NORMAL(0),
        HOVERED(1),
        PRESSED(2),
        DISABLED(3)
        ;
        
        private int nativeInt;
        
        private ButtonState(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:HorizontalAlignment).</em>
     * 
     * === Options:
     * LEFT ::
     *   Align the text's left edge with that of its display area.
     * CENTER ::
     *   Align the text's center with that of its display area.
     * RIGHT ::
     *   Align the text's right edge with that of its display area.
     * 
     * @method _enum_HorizontalAlignment_
     * @return [Symbol]
     * @scope class
     */
    public enum HorizontalAlignment implements EnumMapper.IntegerEnum {
        LEFT(0),
        CENTER(1),
        RIGHT(2)
        ;
        
        private int nativeInt;
        
        private HorizontalAlignment(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:MenuAnchorPosition).</em>
     * 
     * === Options:
     * TOPLEFT ::
     *   
     * TOPRIGHT ::
     *   
     * BOTTOMCENTER ::
     *   
     * 
     * @method _enum_MenuAnchorPosition_
     * @return [Symbol]
     * @scope class
     */
    public enum MenuAnchorPosition implements EnumMapper.IntegerEnum {
        TOPLEFT(0),
        TOPRIGHT(1),
        BOTTOMCENTER(2)
        ;
        
        private int nativeInt;
        
        private MenuAnchorPosition(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :size ::
     *   (Integer) Size of the data structure.
     * :addRef ::
     *   (FFI::Pointer(*)) Called to increment the reference count for the object. Should be called
     *   for every new copy of a pointer to a given object.
     * :release ::
     *   (FFI::Pointer(*)) Called to decrement the reference count for the object. If the reference
     *   count falls to 0 the object should self-delete. Returns true (1) if the
     *   resulting reference count is 0.
     * :hasOneRef ::
     *   (FFI::Pointer(*)) Returns true (1) if the current reference count is 1.
     */
    public static final class Base extends Struct {
        public size_t size = new size_t();
        public Pointer add_ref;
        public Pointer release;
        public Pointer has_one_ref;
        public Base() {
          super(RUNTIME);
        }
        public Base(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    public static interface OnContextInitialized {
    	@Delegate
    	public void onContextInitialized(BrowserProcessHandler self);
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :base ::
     *   (Base) Base structure.
     * :onContextInitialized ::
     *   (FFI::Pointer(*)) Called on the browser process UI thread immediately after the CEF context
     *   has been initialized.
     * :onBeforeChildProcessLaunch ::
     *   (FFI::Pointer(*)) Called before a child process is launched. Will be called on the browser
     *   process UI thread when launching a render process and on the browser
     *   process IO thread when launching a GPU or plugin process. Provides an
     *   opportunity to modify the child process command line. Do not keep a
     *   reference to |command_line| outside of this function.
     * :onRenderProcessThreadCreated ::
     *   (FFI::Pointer(*)) Called on the browser process IO thread after the main thread has been
     *   created for a new render process. Provides an opportunity to specify extra
     *   information that will be passed to
     *   cef_render_process_handler_t::on_render_thread_created() in the render
     *   process. Do not keep a reference to |extra_info| outside of this function.
     * :getPrintHandler ::
     *   (FFI::Pointer(*)) Return the handler for printing on Linux. If a print handler is not
     *   provided then printing will not be supported on the Linux platform.
     */
    public static final class BrowserProcessHandler extends Struct {
        public Base base;
        public OnContextInitialized on_context_initialized;
        public Pointer on_before_child_process_launch;
        public Pointer on_render_process_thread_created;
        public Pointer get_print_handler;
        public BrowserProcessHandler() {
          super(RUNTIME);
        }
        public BrowserProcessHandler(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    public static interface GetBrowserProcessHandler {
    	@Delegate
    	public BrowserProcessHandler getBrowserProcessHandler(App self);
    }
    
    /**
     * Implement this structure to provide handler implementations. Methods will be
     * called by the process and/or thread indicated.
     * 
     * = Fields:
     * :base ::
     *   (Base) Base structure.
     * :onBeforeCommandLineProcessing ::
     *   (FFI::Pointer(*)) Provides an opportunity to view and/or modify command-line arguments before
     *   processing by CEF and Chromium. The |process_type| value will be NULL for
     *   the browser process. Do not keep a reference to the cef_command_line_t
     *   object passed to this function. The CefSettings.command_line_args_disabled
     *   value can be used to start with an NULL command-line object. Any values
     *   specified in CefSettings that equate to command-line arguments will be set
     *   before this function is called. Be cautious when using this function to
     *   modify command-line arguments for non-browser processes as this may result
     *   in undefined behavior including crashes.
     * :onRegisterCustomSchemes ::
     *   (FFI::Pointer(*)) Provides an opportunity to register custom schemes. Do not keep a reference
     *   to the |registrar| object. This function is called on the main thread for
     *   each process and the registered schemes should be the same across all
     *   processes.
     * :getResourceBundleHandler ::
     *   (FFI::Pointer(*)) Return the handler for resource bundle events. If
     *   CefSettings.pack_loading_disabled is true (1) a handler must be returned.
     *   If no handler is returned resources will be loaded from pack files. This
     *   function is called by the browser and render processes on multiple threads.
     * :getBrowserProcessHandler ::
     *   (FFI::Pointer(*)) Return the handler for functionality specific to the browser process. This
     *   function is called on multiple threads in the browser process.
     * :getRenderProcessHandler ::
     *   (FFI::Pointer(*)) Return the handler for functionality specific to the render process. This
     *   function is called on the render process main thread.
     */
    public static final class App extends Struct {
        public Base base;
        public Pointer on_before_command_line_processing;
        public Pointer on_register_custom_schemes;
        public Pointer get_resource_bundle_handler;
        public GetBrowserProcessHandler get_browser_process_handler;
        public Pointer get_render_process_handler;
        public App() {
          this(RUNTIME);
        }
        public App(jnr.ffi.Runtime runtime) {
          super(runtime);
          base = inner(new Base());
          base.size.set(Struct.size(this));
        }
    }
    
    /**
     * This function should be called from the application entry point function to
     * execute a secondary process. It can be used to run secondary processes from
     * the browser client executable (default behavior) or from a separate
     * executable specified by the CefSettings.browser_subprocess_path value. If
     * called for the browser process (identified by no "type" command-line value)
     * it will return immediately with a value of -1. If called for a recognized
     * secondary process it will block until the process should exit and then return
     * the process exit code. The |application| parameter may be NULL. The
     * |windows_sandbox_info| parameter is only used on Windows and may be NULL (see
     * cef_sandbox_win.h for details).
     * 
     * @method executeProcess(args, application, windowsSandboxInfo)
     * @param [MainArgs] args 
     * @param [App] application 
     * @param [FFI::Pointer(*Void)] windowsSandboxInfo 
     * @return [Integer] 
     * @scope class
     */
    public static int executeProcess(@In MainArgs args, @In App application, @In Pointer windowsSandboxInfo) {
        return INSTANCE.executeProcess(args, application, windowsSandboxInfo);
    }
    
    /**
     * This function should be called on the main application thread to initialize
     * the CEF browser process. The |application| parameter may be NULL. A return
     * value of true (1) indicates that it succeeded and false (0) indicates that it
     * failed. The |windows_sandbox_info| parameter is only used on Windows and may
     * be NULL (see cef_sandbox_win.h for details).
     * 
     * @method initialize(args, settings, application, windowsSandboxInfo)
     * @param [MainArgs] args 
     * @param [Settings] settings 
     * @param [App] application 
     * @param [FFI::Pointer(*Void)] windowsSandboxInfo 
     * @return [Integer] 
     * @scope class
     */
    public static int initialize(MainArgs args, Settings settings, App application, Pointer windowsSandboxInfo) {
        return INSTANCE.initialize(args, settings, application, windowsSandboxInfo);
    }
    
    /**
     * This function should be called on the main application thread to shut down
     * the CEF browser process before the application exits.
     * 
     * @method shutdown()
     * @return [nil] 
     * @scope class
     */
    public static void shutdown() {
        INSTANCE.shutdown();
    }
    
    /**
     * Perform a single iteration of CEF message loop processing. This function is
     * used to integrate the CEF message loop into an existing application message
     * loop. Care must be taken to balance performance against excessive CPU usage.
     * This function should only be called on the main application thread and only
     * if cef_initialize() is called with a CefSettings.multi_threaded_message_loop
     * value of false (0). This function will not block.
     * 
     * @method doMessageLoopWork()
     * @return [nil] 
     * @scope class
     */
    public static void doMessageLoopWork() {
        INSTANCE.doMessageLoopWork();
    }
    
    /**
     * Run the CEF message loop. Use this function instead of an application-
     * provided message loop to get the best balance between performance and CPU
     * usage. This function should only be called on the main application thread and
     * only if cef_initialize() is called with a
     * CefSettings.multi_threaded_message_loop value of false (0). This function
     * will block until a quit message is received by the system.
     * 
     * @method runMessageLoop()
     * @return [nil] 
     * @scope class
     */
    public static void runMessageLoop() {
        INSTANCE.runMessageLoop();
    }
    
    /**
     * Quit the CEF message loop that was started by calling cef_run_message_loop().
     * This function should only be called on the main application thread and only
     * if cef_run_message_loop() was used.
     * 
     * @method quitMessageLoop()
     * @return [nil] 
     * @scope class
     */
    public static void quitMessageLoop() {
        INSTANCE.quitMessageLoop();
    }
    
    /**
     * Set to true (1) before calling Windows APIs like TrackPopupMenu that enter a
     * modal message loop. Set to false (0) after exiting the modal message loop.
     * 
     * @method setOsmodalLoop(osModalLoop)
     * @param [Integer] osModalLoop 
     * @return [nil] 
     * @scope class
     */
    public static void setOsmodalLoop(int osModalLoop) {
        INSTANCE.setOsmodalLoop(osModalLoop);
    }
    
    /**
     * Call during process startup to enable High-DPI support on Windows 7 or newer.
     * Older versions of Windows should be left DPI-unaware because they do not
     * support DirectWrite and GDI fonts are kerned very badly.
     * 
     * @method enableHighdpiSupport()
     * @return [nil] 
     * @scope class
     */
    public static void enableHighdpiSupport() {
        INSTANCE.enableHighdpiSupport();
    }
    
    
    public interface CEFInterface {
        
        @Retention(RetentionPolicy.RUNTIME)
        @Target(ElementType.METHOD)
        @interface NativeName {
            String value();
        }
        
        class NativeNameAnnotationFunctionMapper implements FunctionMapper {
            @Override
            public String mapFunctionName(String functionName, Context context) {
                for (Annotation ann : context.getAnnotations()) {
                    if (ann.annotationType() == NativeName.class)
                        return ((NativeName) ann).value();
                }
                return functionName;
            }
        }
        
        
        static class InstanceCreator {
            private static CEFInterface createInstance() {
                CEFInterface lib = LibraryLoader.create(CEFInterface.class)
                  .option(LibraryOption.FunctionMapper, new NativeNameAnnotationFunctionMapper())
                  .load("cef");
                RUNTIME = jnr.ffi.Runtime.getRuntime(lib);
                return lib;
            }
        }
        
        @NativeName("cef_string_wide_set")
        int stringWideSet(Pointer src, NativeLong srcLen, StringWide output, int copy);
        
        @NativeName("cef_string_utf8_set")
        int stringUtf8Set(String src, NativeLong srcLen, StringUtf8 output, int copy);
        
        @NativeName("cef_string_utf16_set")
        int stringUtf16Set(Pointer src, NativeLong srcLen, StringUtf16 output, int copy);
        
        @NativeName("cef_string_wide_clear")
        void stringWideClear(StringWide str);
        
        @NativeName("cef_string_utf8_clear")
        void stringUtf8Clear(StringUtf8 str);
        
        @NativeName("cef_string_utf16_clear")
        void stringUtf16Clear(StringUtf16 str);
        
        @NativeName("cef_string_wide_cmp")
        int stringWideCmp(StringWide str1, StringWide str2);
        
        @NativeName("cef_string_utf8_cmp")
        int stringUtf8Cmp(StringUtf8 str1, StringUtf8 str2);
        
        @NativeName("cef_string_utf16_cmp")
        int stringUtf16Cmp(StringUtf16 str1, StringUtf16 str2);
        
        @NativeName("cef_string_wide_to_utf8")
        int stringWideToUtf8(Pointer src, NativeLong srcLen, StringUtf8 output);
        
        @NativeName("cef_string_utf8_to_wide")
        int stringUtf8ToWide(String src, NativeLong srcLen, StringWide output);
        
        @NativeName("cef_string_wide_to_utf16")
        int stringWideToUtf16(Pointer src, NativeLong srcLen, StringUtf16 output);
        
        @NativeName("cef_string_utf16_to_wide")
        int stringUtf16ToWide(Pointer src, NativeLong srcLen, StringWide output);
        
        @NativeName("cef_string_utf8_to_utf16")
        int stringUtf8ToUtf16(String src, NativeLong srcLen, StringUtf16 output);
        
        @NativeName("cef_string_utf16_to_utf8")
        int stringUtf16ToUtf8(Pointer src, NativeLong srcLen, StringUtf8 output);
        
        @NativeName("cef_string_ascii_to_wide")
        int stringAsciiToWide(String src, NativeLong srcLen, StringWide output);
        
        @NativeName("cef_string_ascii_to_utf16")
        int stringAsciiToUtf16(String src, NativeLong srcLen, StringUtf16 output);
        
        @NativeName("cef_string_userfree_wide_alloc")
        StringWide stringUserfreeWideAlloc();
        
        @NativeName("cef_string_userfree_utf8_alloc")
        StringUtf8 stringUserfreeUtf8Alloc();
        
        @NativeName("cef_string_userfree_utf16_alloc")
        StringUtf16 stringUserfreeUtf16Alloc();
        
        @NativeName("cef_string_userfree_wide_free")
        void stringUserfreeWideFree(StringWide str);
        
        @NativeName("cef_string_userfree_utf8_free")
        void stringUserfreeUtf8Free(StringUtf8 str);
        
        @NativeName("cef_string_userfree_utf16_free")
        void stringUserfreeUtf16Free(StringUtf16 str);
        
        @NativeName("cef_get_xdisplay")
        XDisplay getXdisplay();
        
        @NativeName("cef_execute_process")
        int executeProcess(MainArgs args, App application, Pointer windowsSandboxInfo);
        
        @NativeName("cef_initialize")
        int initialize(MainArgs args, Settings settings, App application, Pointer windowsSandboxInfo);
        
        @NativeName("cef_shutdown")
        void shutdown();
        
        @NativeName("cef_do_message_loop_work")
        void doMessageLoopWork();
        
        @NativeName("cef_run_message_loop")
        void runMessageLoop();
        
        @NativeName("cef_quit_message_loop")
        void quitMessageLoop();
        
        @NativeName("cef_set_osmodal_loop")
        void setOsmodalLoop(int osModalLoop);
        
        @NativeName("cef_enable_highdpi_support")
        void enableHighdpiSupport();
        
    }
}
